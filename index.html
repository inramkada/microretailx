<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tesseract 4D – XSHADOWS OPS</title>
  <style>
    html, body { margin: 0; padding: 0; background: #0d1117; overflow: hidden; }
    canvas { display: block; }
    .title {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: monospace;
      font-size: 1.6rem;
      z-index: 10;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="title">XSHADOWS OPS<br><strong>TESSERACT 4D</strong></div>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 40;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 16 vértices del tesseract (hipercubo 4D)
    const vertices4D = [];
    for (let i = 0; i < 16; i++) {
      vertices4D.push([
        (i & 1) ? 1 : -1,
        (i & 2) ? 1 : -1,
        (i & 4) ? 1 : -1,
        (i & 8) ? 1 : -1
      ]);
    }

    // Función para rotar en un plano de 4D (ej: XY, XW, etc.)
    function rotate4D(v, i, j, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const temp = v[i] * cos - v[j] * sin;
      v[j] = v[i] * sin + v[j] * cos;
      v[i] = temp;
    }

    // Proyectar de 4D a 3D
    function project4Dto3D(v4) {
      const w = 2 / (4 - v4[3]); // perspectiva 4D→3D
      return new THREE.Vector3(v4[0] * w * 5, v4[1] * w * 5, v4[2] * w * 5);
    }

    // Geometría de puntos
    const material = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.4 });
    const geometry = new THREE.BufferGeometry();
    const projectedVerts = vertices4D.map(project4Dto3D);
    geometry.setFromPoints(projectedVerts);
    const points = new THREE.Points(geometry, material);
    scene.add(points);

    // Geometría de líneas (conectamos vértices con 1 bit de diferencia)
    const lineGroup = new THREE.Group();
    for (let i = 0; i < 16; i++) {
      for (let j = i + 1; j < 16; j++) {
        const diff = vertices4D[i].reduce((acc, val, k) => acc + (val !== vertices4D[j][k] ? 1 : 0), 0);
        if (diff === 1) {
          const lineGeom = new THREE.BufferGeometry().setFromPoints([
            projectedVerts[i].clone(),
            projectedVerts[j].clone()
          ]);
          const lineMat = new THREE.LineBasicMaterial({ color: 0x3399ff, transparent: true, opacity: 0.5 });
          const line = new THREE.Line(lineGeom, lineMat);
          lineGroup.add(line);
        }
      }
    }
    scene.add(lineGroup);

    // Animación
    function animate() {
      requestAnimationFrame(animate);

      for (let v of vertices4D) {
        rotate4D(v, 0, 3, 0.01); // XW
        rotate4D(v, 1, 2, 0.015); // YZ
      }

      const updatedVerts = vertices4D.map(project4Dto3D);
      geometry.setFromPoints(updatedVerts);

      // Actualiza las líneas
      let k = 0;
      for (let i = 0; i < 16; i++) {
        for (let j = i + 1; j < 16; j++) {
          const diff = vertices4D[i].reduce((acc, val, d) => acc + (val !== vertices4D[j][d] ? 1 : 0), 0);
          if (diff === 1) {
            const line = lineGroup.children[k++];
            line.geometry.setFromPoints([
              updatedVerts[i].clone(),
              updatedVerts[j].clone()
            ]);
          }
        }
      }

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
