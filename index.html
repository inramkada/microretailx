
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Gato Neuronal 3D :: microretailX</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background-color: #0d1117;
      overflow: hidden;
    }
    .title {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.8rem;
      font-family: 'Segoe UI', sans-serif;
      color: white;
      z-index: 10;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="title">XSHADOWS OPS by <strong>microretailX</strong></div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';

    let scene, camera, renderer, particles = [], targetPoints = [], lines = [];
    let clickCount = 0, structureBuilt = false;
    let followRotation = false;
    const mouse = { x: 0, y: 0 };

    const vertexPositions = [
      [0, 0, 1.5], [1, 0, 0], [0, 1, 0], [-1, 0, 0], [0, -1, 0], [0, 0, -1.2],
      [-0.6, 1, 0.3], [-1.0, 1.8, 0], [-0.2, 1.7, 0],
      [0.6, 1, 0.3], [1.0, 1.8, 0], [0.2, 1.7, 0],
      [-0.3, 0.2, 1.2], [0.3, 0.2, 1.2],
      [0, -0.2, 1.3]
    ];

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.z = 6;

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const ambient = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambient);

      const directional = new THREE.DirectionalLight(0xffffff, 1);
      directional.position.set(2, 2, 4);
      scene.add(directional);

      // Crear los puntos estructurales
      const structureGroup = new THREE.Group();

      const pointGeo = new THREE.SphereGeometry(0.05, 6, 6);
      const pointMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });

      for (let i = 0; i < vertexPositions.length; i++) {
        const [x, y, z] = vertexPositions[i];
        const mesh = new THREE.Mesh(pointGeo, pointMat.clone());
        mesh.position.set(x, y, z);
        mesh.visible = false;
        targetPoints.push({ mesh, absorbed: false });
        structureGroup.add(mesh);
      }

      // Crear líneas entre puntos cercanos
      const lineMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 });
      const lineGeo = new THREE.BufferGeometry();
      const lineVertices = [];

      for (let i = 0; i < vertexPositions.length; i++) {
        for (let j = i + 1; j < vertexPositions.length; j++) {
          const p1 = new THREE.Vector3(...vertexPositions[i]);
          const p2 = new THREE.Vector3(...vertexPositions[j]);
          if (p1.distanceTo(p2) < 1.2) {
            lineVertices.push(...p1.toArray(), ...p2.toArray());
          }
        }
      }

      lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(lineVertices, 3));
      const lineMesh = new THREE.LineSegments(lineGeo, lineMat);
      lineMesh.visible = false;
      structureGroup.add(lineMesh);

      scene.add(structureGroup);

      // Click = crear partículas
      window.addEventListener('click', () => {
        clickCount++;
        for (let i = 0; i < 40; i++) {
          const particle = createParticle();
          scene.add(particle.mesh);
          particles.push(particle);
        }

        if (clickCount >= 6 && !structureBuilt) {
          structureBuilt = true;
          targetPoints.forEach(p => p.mesh.visible = true);
          lineMesh.visible = true;
          followRotation = true;
        }
      });

      window.addEventListener('mousemove', (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function createParticle() {
      const geometry = new THREE.SphereGeometry(0.04, 6, 6);
      const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const mesh = new THREE.Mesh(geometry, material);
      const pos = new THREE.Vector3(
        (Math.random() - 0.5) * 10,
        (Math.random() - 0.5) * 10,
        (Math.random() - 0.5) * 10
      );
      mesh.position.copy(pos);

      return {
        mesh,
        velocity: new THREE.Vector3(
          (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1
        ),
        absorbed: false,
        target: null
      };
    }

    function animate() {
      requestAnimationFrame(animate);

      if (structureBuilt) {
        const targetRotX = mouse.y * 0.5;
        const targetRotY = mouse.x * 0.5;
        scene.rotation.x += (targetRotX - scene.rotation.x) * 0.05;
        scene.rotation.y += (targetRotY - scene.rotation.y) * 0.05;
      }

      // Movimiento partículas
      for (let p of particles) {
        if (!p.absorbed) {
          let nearest = null;
          let minDist = Infinity;
          for (let t of targetPoints) {
            if (!t.absorbed) {
              const d = p.mesh.position.distanceTo(t.mesh.position);
              if (d < minDist) {
                minDist = d;
                nearest = t;
              }
            }
          }
          if (nearest && minDist < 0.2) {
            p.absorbed = true;
            nearest.absorbed = true;
            p.target = nearest;
          } else {
            p.mesh.position.add(p.velocity);
          }
        } else if (p.target) {
          p.mesh.position.lerp(p.target.mesh.position, 0.1);
        }
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
