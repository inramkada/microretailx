<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MICRORETAILX</title>

  <meta name="referrer" content="no-referrer">
  <meta http-equiv="Permissions-Policy"
        content="geolocation=(), microphone=(), camera=(), payment=(), usb=()">

  <style>
    html, body{
      margin:0; padding:0; height:100%;
      background:#000; overflow:hidden; color:#fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
                   "Liberation Mono", "Courier New", monospace;
    }
    canvas{ display:block; width:100vw; height:100vh; }

    .ui-layer{ position:fixed; inset:0; pointer-events:none; z-index:10; }
    .top-bar{
      position:absolute; top:0; left:0; right:0;
      padding:14px 18px;
      background:rgba(0,0,0,0.78);
      border-bottom:1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
      display:flex;
    }
    .brand{
      font-size:12px; letter-spacing:4px; font-weight:900;
      opacity:0.92; color:rgba(255,255,255,0.92);
      mix-blend-mode:difference;
    }

    .footer-bar{
      position:absolute; bottom:0; left:0; right:0;
      padding:14px 18px 12px;
      background:rgba(0,0,0,0.78);
      border-top:1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
      display:flex; flex-direction:column; align-items:center; gap:8px;
      pointer-events:auto;
    }
    .footer-links{ display:flex; gap:22px; font-size:11px; letter-spacing:2px; opacity:0.65; }
    .footer-links a{ color:#fff; text-decoration:none; opacity:0.75; pointer-events:auto; }
    .footer-links a:hover{ opacity:1; text-decoration:underline; }
    .copyright{ font-size:9px; letter-spacing:1px; opacity:0.45; text-align:center; }

    @media (max-width: 600px){
      .brand { font-size: 11px; letter-spacing: 3px; }
      .footer-links { flex-wrap: wrap; justify-content:center; gap: 14px; }
    }
  </style>
</head>

<body>
  <canvas id="view"></canvas>

  <div class="ui-layer">
    <div class="top-bar"><div class="brand">MICRORETAILX</div></div>
    <div class="footer-bar">
      <div class="footer-links">
        <a href="terms.html">TERMS</a>
        <a href="privacy.html">PRIVACY</a>
        <a href="cookies.html">COOKIES</a>
        <a href="legal.html">LEGAL</a>
      </div>
      <div class="copyright">© 2023–2026 MICRORETAILX LLC. ALL RIGHTS RESERVED.</div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ---------- helpers ----------
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  const lerp  = (a,b,t)=> a + (b-a)*t;
  const ease  = t => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;

  // HSV -> RGB (0..1)
  function hsv2rgb(h,s,v){
    h = ((h % 1) + 1) % 1;
    const i = Math.floor(h*6);
    const f = h*6 - i;
    const p = v*(1-s);
    const q = v*(1-f*s);
    const t = v*(1-(1-f)*s);
    let r,g,b;
    switch(i % 6){
      case 0: r=v; g=t; b=p; break;
      case 1: r=q; g=v; b=p; break;
      case 2: r=p; g=v; b=t; break;
      case 3: r=p; g=q; b=v; break;
      case 4: r=t; g=p; b=v; break;
      case 5: r=v; g=p; b=q; break;
    }
    return { r: (r*255)|0, g: (g*255)|0, b: (b*255)|0 };
  }

  // ---------- canvas ----------
  const view = document.getElementById("view");
  const vctx = view.getContext("2d", { alpha: false });

  const simCanvas = document.createElement("canvas");
  const sctx = simCanvas.getContext("2d", { willReadFrequently: true });

  const UA = navigator.userAgent || "";
  const IS_IOS =
    /iPhone|iPad|iPod/i.test(UA) ||
    (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
  const IS_MOBILE = /Mobi|Android|iPhone|iPad/i.test(UA);

  const DPR_CAP = IS_IOS ? 1.6 : 2;
  let dpr = Math.min(DPR_CAP, window.devicePixelRatio || 1);

  let W=0, H=0, simW=0, simH=0;

  // slime fields
  let trailA, trailB, xField, imgData, img8;
  let agents = [];
  let foods  = [];

  // pre-phase particles
  let particles = [];
  let started = false;
  let absorption = 0;     // 0..1
  let xComplete = 0;      // 0..1
  let startAt = 0;

  let lastMouseFoodAt = 0;
  let lastFrame = performance.now();
  let frame = 0;

  // cursor influence
  let cursorX = 0, cursorY = 0;
  let cursorEnergy = 0;

  // ---------- config ----------
  const CFG = {
    gridMax: IS_MOBILE ? 560 : 860,

    particleCount: IS_MOBILE ? 1300 : 2200,
    particleSpeed: IS_MOBILE ? 0.55 : 0.75,
    particleJitter: 0.35,

    absorbRampMs: 1000,
    mazeEnableMs: 650,
    xScoreWarmupMs: 900,
    xScoreSmoothing: 0.08,

    agentCount: IS_MOBILE ? 7200 : 13500,
    step: IS_MOBILE ? 0.95 : 1.08,

    sensorDist: IS_MOBILE ? 6.5 : 7.9,
    sensorAngle: 0.55,
    turnSpeed: 0.34,

    deposit: 0.95,
    decay: IS_MOBILE ? 0.973 : 0.979,
    diffuseEvery: 2,
    diffuseMix: 0.42,

    // X thickness (MORE BODY)
    xBias: 0.95,
    xWidthPx: IS_MOBILE ? 5.3 : 7.2,
    xInk: 0.40,

    // mouse interaction
    foodRadius: IS_MOBILE ? 18 : 22,
    foodStrength: 1.75,
    foodLifeMs: 1150,
    mouseFoodEveryMs: IS_MOBILE ? 42 : 26,

    crush: 0.028,

    // screen neon body
    xStrokeCore: IS_MOBILE ? 4.4 : 6.2,
    xStrokeGlow: IS_MOBILE ? 14 : 20
  };

  function idx(x, y){ return x + y * simW; }

  function resize() {
    dpr = Math.min(DPR_CAP, window.devicePixelRatio || 1);
    W = window.innerWidth | 0;
    H = window.innerHeight | 0;

    view.width  = (W * dpr) | 0;
    view.height = (H * dpr) | 0;
    view.style.width = W + "px";
    view.style.height = H + "px";
    vctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    const maxSide = CFG.gridMax;
    const aspect = W / Math.max(1, H);
    if (W >= H) {
      simW = maxSide;
      simH = Math.max(180, (maxSide / aspect) | 0);
    } else {
      simH = maxSide;
      simW = Math.max(180, (maxSide * aspect) | 0);
    }

    simCanvas.width = simW;
    simCanvas.height = simH;

    const n = simW * simH;
    trailA = new Float32Array(n);
    trailB = new Float32Array(n);
    xField = new Float32Array(n);
    imgData = sctx.createImageData(simW, simH);
    img8 = imgData.data;

    buildXField();
    seedAgents(true);
    seedParticles(true);
  }
  window.addEventListener("resize", resize);

  function buildXField() {
    const w=simW, h=simH;
    const a = (h - 1) / Math.max(1, (w - 1));
    const inv = 1 / Math.sqrt(1 + a*a);

    const sigma = CFG.xWidthPx;
    const sigma2 = sigma*sigma;

    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        const d1 = Math.abs(a*x - y) * inv;
        const d2 = Math.abs(a*x + y - (h - 1)) * inv;
        const d  = Math.min(d1, d2);
        xField[idx(x,y)] = Math.exp(-(d*d)/(2*sigma2));
      }
    }
  }

  function seedAgents(reset=false){
    if (reset) { trailA.fill(0); trailB.fill(0); }
    agents.length = 0;
    const n = CFG.agentCount;
    for (let i=0; i<n; i++){
      let x,y, tries=0;
      while(true){
        x = (Math.random()*simW)|0;
        y = (Math.random()*simH)|0;
        const xf = xField[idx(x,y)];
        if (Math.random() < 0.14 + 0.86*xf || tries++ > 10) break;
      }
      agents.push({ x: x + Math.random(), y: y + Math.random(), a: Math.random()*Math.PI*2 });
    }
  }

  function seedParticles(reset=false){
    if (reset) particles.length = 0;
    const n = CFG.particleCount;
    while(particles.length < n){
      particles.push({
        x: Math.random()*W,
        y: Math.random()*H,
        vx: (Math.random()-0.5)*CFG.particleSpeed*2,
        vy: (Math.random()-0.5)*CFG.particleSpeed*2,
      });
    }
  }

  function depositAt(f, x, y, amt){
    const xi = x|0, yi = y|0;
    if (xi<0||yi<0||xi>=simW||yi>=simH) return;
    const k = idx(xi, yi);
    f[k] = Math.min(1.0, f[k] + amt);
  }
  function sampleField(f, x, y){
    const xi = x|0, yi = y|0;
    if (xi<0||yi<0||xi>=simW||yi>=simH) return 0;
    return f[idx(xi, yi)];
  }

  function diffuse(src, dst, mix){
    const w=simW, h=simH;
    for (let y=1; y<h-1; y++){
      const row=y*w;
      for (let x=1; x<w-1; x++){
        const k=row+x;
        const v = src[k] +
          src[k-1] + src[k+1] +
          src[k-w] + src[k+w] +
          src[k-w-1] + src[k-w+1] +
          src[k+w-1] + src[k+w+1];
        const blur = v/9;
        dst[k] = src[k]*(1-mix) + blur*mix;
      }
    }
    for (let x=0; x<w; x++){ dst[x]=src[x]; dst[x+(h-1)*w]=src[x+(h-1)*w]; }
    for (let y=0; y<h; y++){ dst[y*w]=src[y*w]; dst[(w-1)+y*w]=src[(w-1)+y*w]; }
  }

  function inkXLine(amount){
    const w=simW, h=simH;
    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        const xf = xField[idx(x,y)];
        if (xf > 0.10) trailA[idx(x,y)] = Math.max(trailA[idx(x,y)], amount * xf);
      }
    }
  }

  function snapToX_sim(x, y){
    const w=simW, h=simH;
    const a = (h - 1) / Math.max(1, (w - 1));
    const y1 = a*x;
    const y2 = (h - 1) - a*x;
    const d1 = Math.abs(y - y1);
    const d2 = Math.abs(y - y2);
    return d1 < d2 ? {x, y:y1} : {x, y:y2};
  }

  function addMouseFood(clientX, clientY, strong=false){
    const now = performance.now();
    if (!strong && now - lastMouseFoodAt < CFG.mouseFoodEveryMs) return;
    lastMouseFoodAt = now;

    const el = document.elementFromPoint(clientX, clientY);
    const a = el && el.closest ? el.closest("a") : null;
    if (a) return;

    let fx = clamp((clientX/W)*simW, 0, simW-1);
    let fy = clamp((clientY/H)*simH, 0, simH-1);
    const s = snapToX_sim(fx, fy);
    fx = clamp(s.x, 0, simW-1);
    fy = clamp(s.y, 0, simH-1);

    foods.push({
      x: fx, y: fy,
      life: strong ? CFG.foodLifeMs*1.8 : CFG.foodLifeMs,
      amp: 1.0
    });

    depositAt(trailA, fx, fy, strong ? 1.0 : 0.62);
    cursorEnergy = clamp(cursorEnergy + (strong ? 0.55 : 0.22), 0, 1);
  }

  function startOnFirstClick(e){
    const el = document.elementFromPoint(e.clientX, e.clientY);
    const a = el && el.closest ? el.closest("a") : null;
    if (a) return;

    if (!started) {
      started = true;
      startAt = performance.now();
      absorption = 0;
      xComplete = 0;
      foods.length = 0;

      inkXLine(0.62);
      addMouseFood(e.clientX, e.clientY, true);
    } else {
      addMouseFood(e.clientX, e.clientY, true);
    }
  }

  window.addEventListener("pointerdown", startOnFirstClick, { passive:true });

  window.addEventListener("pointermove", (e) => {
    cursorX = e.clientX; cursorY = e.clientY;
    if (!started) return;
    addMouseFood(e.clientX, e.clientY, false);
  }, { passive:true });

  function stepParticles(dt){
    const sp = CFG.particleSpeed;
    const jit = CFG.particleJitter;

    if (started) {
      const t = performance.now() - startAt;
      absorption = clamp(t / CFG.absorbRampMs, 0, 1);
    }

    for (let i=0; i<particles.length; i++){
      const p = particles[i];

      p.vx += (Math.random()-0.5)*jit*0.02;
      p.vy += (Math.random()-0.5)*jit*0.02;

      const v = Math.hypot(p.vx, p.vy) || 1;
      if (v > sp) { p.vx = (p.vx/v)*sp; p.vy = (p.vy/v)*sp; }

      if (absorption > 0) {
        const sx = (p.x / W) * simW;
        const sy = (p.y / H) * simH;
        const s = snapToX_sim(sx, sy);

        const tx = (s.x / simW) * W;
        const ty = (s.y / simH) * H;

        const dx = tx - p.x;
        const dy = ty - p.y;

        const pull = 0.0025 + 0.0105*absorption;
        p.vx += dx * pull;
        p.vy += dy * pull;

        // deposit into X as they get absorbed
        const dep = 0.10 + 0.28*absorption;
        depositAt(trailA, s.x, s.y, dep);
      }

      p.x += p.vx * dt * 0.06;
      p.y += p.vy * dt * 0.06;

      if (p.x < 0) p.x += W; else if (p.x >= W) p.x -= W;
      if (p.y < 0) p.y += H; else if (p.y >= H) p.y -= H;
    }
  }

  function computeXCompleteness(){
    const samples = IS_MOBILE ? 80 : 120;
    let acc = 0;
    for (let i=0; i<samples; i++){
      const t = i/(samples-1);
      const x = t*(simW-1);
      const y1 = t*(simH-1);
      const y2 = (simH-1) - y1;

      const k1 = idx(x|0, y1|0);
      const k2 = idx(x|0, y2|0);

      const v1 = trailA[k1] * (0.55 + 0.45*xField[k1]);
      const v2 = trailA[k2] * (0.55 + 0.45*xField[k2]);

      acc += clamp(v1, 0, 1);
      acc += clamp(v2, 0, 1);
    }
    const raw = acc / (samples*2);
    xComplete = lerp(xComplete, clamp(raw*1.25, 0, 1), CFG.xScoreSmoothing);
  }

  function stepSlime(dtMs){
    for (let i=foods.length-1; i>=0; i--){
      foods[i].life -= dtMs;
      if (foods[i].life <= 0) foods.splice(i, 1);
      else foods[i].amp = foods[i].life / CFG.foodLifeMs;
    }

    const step = CFG.step;
    const sDist = CFG.sensorDist;
    const sAng  = CFG.sensorAngle;
    const turn  = CFG.turnSpeed;

    const xBias = CFG.xBias;
    const foodStr = CFG.foodStrength;

    for (let i=0; i<agents.length; i++){
      const p = agents[i];

      const la = p.a - sAng;
      const ra = p.a + sAng;

      const fx = p.x + Math.cos(p.a)*sDist;
      const fy = p.y + Math.sin(p.a)*sDist;
      const lx = p.x + Math.cos(la)*sDist;
      const ly = p.y + Math.sin(la)*sDist;
      const rx = p.x + Math.cos(ra)*sDist;
      const ry = p.y + Math.sin(ra)*sDist;

      let fF = sampleField(trailA, fx, fy);
      let fL = sampleField(trailA, lx, ly);
      let fR = sampleField(trailA, rx, ry);

      fF += xBias * sampleField(xField, fx, fy);
      fL += xBias * sampleField(xField, lx, ly);
      fR += xBias * sampleField(xField, rx, ry);

      if (foods.length){
        let addF=0, addL=0, addR=0;
        const rr = CFG.foodRadius;
        const rr2 = 2*rr*rr;
        for (let j=0; j<foods.length; j++){
          const fd = foods[j];
          const amp = fd.amp;

          const dxF = fx - fd.x, dyF = fy - fd.y;
          const dxL = lx - fd.x, dyL = ly - fd.y;
          const dxR = rx - fd.x, dyR = ry - fd.y;

          addF += Math.exp(-(dxF*dxF + dyF*dyF)/rr2) * amp;
          addL += Math.exp(-(dxL*dxL + dyL*dyL)/rr2) * amp;
          addR += Math.exp(-(dxR*dxR + dyR*dyR)/rr2) * amp;
        }
        fF += foodStr * addF;
        fL += foodStr * addL;
        fR += foodStr * addR;
      }

      if (fF > fL && fF > fR) {
        // straight
      } else if (fL > fR) {
        p.a -= turn;
      } else if (fR > fL) {
        p.a += turn;
      } else {
        p.a += (Math.random()-0.5)*0.15;
      }

      p.x += Math.cos(p.a)*step;
      p.y += Math.sin(p.a)*step;

      if (p.x < 0) p.x += simW; else if (p.x >= simW) p.x -= simW;
      if (p.y < 0) p.y += simH; else if (p.y >= simH) p.y -= simH;

      depositAt(trailA, p.x, p.y, CFG.deposit);
    }

    // decay + diffusion
    const d = CFG.decay;
    for (let k=0; k<trailA.length; k++) trailA[k] *= d;

    if ((frame % CFG.diffuseEvery) === 0) {
      diffuse(trailA, trailB, CFG.diffuseMix);
      const tmp = trailA; trailA = trailB; trailB = tmp;
    }
  }

  function renderParticles(now){
    vctx.fillStyle = "#000";
    vctx.fillRect(0,0,W,H);

    // cyan-ish particles, but with slight shimmer as absorption grows
    vctx.save();
    vctx.globalCompositeOperation = "lighter";

    const t = now * 0.001;
    const hue = 0.52 + 0.06*Math.sin(t*1.2); // cyan base
    const base = hsv2rgb(hue, 0.9, 1.0);

    for (let i=0; i<particles.length; i++){
      const p = particles[i];
      const r = 1.0 + absorption*0.9;
      const a = 0.22 + absorption*0.36;
      vctx.fillStyle = `rgba(${base.r},${base.g},${base.b},${a})`;
      vctx.beginPath();
      vctx.arc(p.x, p.y, r, 0, Math.PI*2);
      vctx.fill();
    }

    // faint diagonal hint once absorption begins
    if (absorption > 0.04) {
      const hint = clamp(absorption*0.18, 0, 0.18);
      vctx.strokeStyle = `rgba(${base.r},${base.g},${base.b},${hint})`;
      vctx.lineWidth = IS_MOBILE ? 2.4 : 3.0;
      vctx.beginPath();
      vctx.moveTo(0,0); vctx.lineTo(W,H);
      vctx.moveTo(W,0); vctx.lineTo(0,H);
      vctx.stroke();
    }

    vctx.restore();

    if (!started) {
      vctx.save();
      vctx.fillStyle = "rgba(255,255,255,0.14)";
      vctx.font = "600 10px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      vctx.textAlign = "center";
      vctx.fillText("CLICK", W/2, H/2 + 4);
      vctx.restore();
    }
  }

  function renderMaze(now){
    const n = simW * simH;
    const t = now * 0.001;

    // ---- “people flip” color logic ----
    // Start cyan. As X completes, we unlock:
    // - fast hue rotation on the X band
    // - iridescent interference on filaments
    // - cursor energy kicks pulses
    const unlock = ease(clamp(xComplete, 0, 1));
    cursorEnergy = lerp(cursorEnergy, 0, 0.06);

    // base hue rotates slowly; unlocked adds fast rotation + strobe pulses
    const baseHue = 0.52;                     // cyan start
    const slow = 0.06 * Math.sin(t*0.45);
    const fast = unlock * (0.55*Math.sin(t*1.35) + 0.25*Math.sin(t*3.2));
    const pulse = unlock * cursorEnergy * (0.18*Math.sin(t*14.0));
    const H0 = baseHue + slow + fast + pulse;

    for (let k=0, p=0; k<n; k++, p+=4){
      const tr = trailA[k];
      const v  = tr <= 0 ? 0 : Math.pow(clamp(tr, 0, 1), 0.62);

      const xf = xField[k];                         // stronger on X
      const c  = clamp(v * (0.82 + 0.38*xf), 0, 1);

      // iridescent interference
      const x = (k % simW);
      const y = (k / simW) | 0;
      const wave = Math.sin((x*0.035 + y*0.028) + t*(1.2 + 2.4*unlock));
      const wave2 = Math.sin((x*0.018 - y*0.021) + t*(2.1 + 3.8*unlock));
      const ir = (0.5 + 0.5*wave) * (0.35 + 0.65*unlock) + (0.5 + 0.5*wave2)*0.18*unlock;

      // hue varies slightly with xField + interference
      const hue = H0 + 0.22*ir + 0.10*xf*unlock;
      const sat = 0.88 + 0.10*unlock;
      const val = clamp(0.10 + 1.15*c, 0, 1);

      const rgb = hsv2rgb(hue, sat, val);

      // white-hot core for thick X
      const hot = Math.pow(c, 0.42) * (0.20 + 0.32*xf);

      const on = c < CFG.crush ? 0 : 1;
      img8[p+0] = on ? clamp(rgb.r + 255*hot, 0, 255) | 0 : 0;
      img8[p+1] = on ? clamp(rgb.g + 255*hot*0.55, 0, 255) | 0 : 0;
      img8[p+2] = on ? clamp(rgb.b + 255*hot*0.85, 0, 255) | 0 : 0;
      img8[p+3] = 255;
    }

    sctx.putImageData(imgData, 0, 0);

    vctx.fillStyle = "#000";
    vctx.fillRect(0,0,W,H);
    vctx.imageSmoothingEnabled = true;
    vctx.drawImage(simCanvas, 0,0,simW,simH, 0,0,W,H);

    // screen-space neon body for the X (more body, more glow)
    const unlock = ease(clamp(xComplete, 0, 1));
    const hueX = 0.52 + unlock*(0.55*Math.sin(t*1.35) + 0.20*Math.sin(t*4.8));
    const col = hsv2rgb(hueX, 0.95, 1.0);

    const alpha = clamp(0.14 + 0.62*unlock, 0, 0.85);

    vctx.save();
    vctx.globalCompositeOperation = "lighter";
    vctx.lineCap = "round";

    // glow
    vctx.strokeStyle = `rgba(${col.r},${col.g},${col.b},${alpha*0.35})`;
    vctx.lineWidth = CFG.xStrokeGlow;
    vctx.beginPath();
    vctx.moveTo(0,0); vctx.lineTo(W,H);
    vctx.moveTo(W,0); vctx.lineTo(0,H);
    vctx.stroke();

    // core
    vctx.strokeStyle = `rgba(${col.r},${col.g},${col.b},${alpha})`;
    vctx.lineWidth = CFG.xStrokeCore;
    vctx.beginPath();
    vctx.moveTo(0,0); vctx.lineTo(W,H);
    vctx.moveTo(W,0); vctx.lineTo(0,H);
    vctx.stroke();

    // center knot bloom
    const cx=W/2, cy=H/2;
    const rr = Math.min(W,H) * 0.18;
    const g = vctx.createRadialGradient(cx,cy,0,cx,cy,rr);
    g.addColorStop(0, `rgba(${col.r},${col.g},${col.b},${alpha*0.45})`);
    g.addColorStop(0.32, `rgba(${col.r},${col.g},${col.b},${alpha*0.14})`);
    g.addColorStop(1, "rgba(0,0,0,0)");
    vctx.fillStyle = g;
    vctx.beginPath(); vctx.arc(cx,cy,rr,0,Math.PI*2); vctx.fill();

    vctx.restore();
  }

  function loop(now){
    const dt = clamp(now - lastFrame, 8, 40);
    lastFrame = now;

    // always update particles
    stepParticles(dt);

    if (!started) {
      renderParticles(now);
      requestAnimationFrame(loop);
      return;
    }

    const t = now - startAt;

    // early: keep ink feeding the X so it locks thick & clean
    if (t < 1100) inkXLine(CFG.xInk);

    // slime step
    stepSlime(dt);

    // compute completeness
    if (t > CFG.xScoreWarmupMs) computeXCompleteness();

    // blend particles -> maze
    const mix = clamp((t - CFG.mazeEnableMs) / 800, 0, 1);
    if (mix < 1) {
      renderParticles(now);
      vctx.save();
      vctx.globalAlpha = ease(mix);
      renderMaze(now);
      vctx.restore();
    } else {
      renderMaze(now);
    }

    frame++;
    requestAnimationFrame(loop);
  }

  // reset key
  window.addEventListener("keydown", (e) => {
    if (e.key === "r" || e.key === "R") {
      started = false;
      absorption = 0;
      xComplete = 0;
      foods.length = 0;
      seedAgents(true);
      seedParticles(true);
    }
  });

  // extra “energy” on clicks/moves
  window.addEventListener("pointermove", () => { cursorEnergy = clamp(cursorEnergy + 0.01, 0, 1); }, { passive:true });

  resize();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
