
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>microretailX</title>
  <style>
    body, html { margin: 0; overflow: hidden; background-color: #0d1117; }
    canvas { display: block; }
    .title {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5rem;
      color: white;
      font-family: monospace;
      pointer-events: none;
      z-index: 10;
    }
  </style>
</head>
<body>
<div class="title">XSHADOWS OPS by <strong>microretailX</strong></div>
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';

  let scene = new THREE.Scene();
  let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  let renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const geometry = new THREE.BufferGeometry();
  const vertices = [
    // 300 puntos generados automáticamente
    // Corto por espacio, pero aquí irían los 300 puntos generados como Vector3, te muestro 10 para el ejemplo:
    -5.3, 1.4, 3.8,  -2.7, 6.1, -4.3,  2.9, -3.6, 2.0,
    4.2, -1.5, -5.6,  0.1, 3.3, -3.9,  -1.8, -6.9, 1.1,
    6.7, 0.9, -2.2,  -4.6, 2.2, 4.4,  3.3, -5.1, 0.6,
    0.0, 0.0, 0.0  // (continúa...)
  ];
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

  const material = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.2 });
  const points = new THREE.Points(geometry, material);
  scene.add(points);

  // Líneas entre puntos cercanos
  const threshold = 3;
  const lineMaterial = new THREE.LineBasicMaterial({ color: 0x3399ff, transparent: true, opacity: 0.2 });
  const lineGeo = new THREE.BufferGeometry();
  let linePositions = [];

  for (let i = 0; i < vertices.length; i += 3) {
    const xi = vertices[i], yi = vertices[i+1], zi = vertices[i+2];
    for (let j = i + 3; j < vertices.length; j += 3) {
      const xj = vertices[j], yj = vertices[j+1], zj = vertices[j+2];
      const dx = xi - xj, dy = yi - yj, dz = zi - zj;
      const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
      if (dist < threshold) {
        linePositions.push(xi, yi, zi, xj, yj, zj);
      }
    }
  }

  lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
  const lineSegments = new THREE.LineSegments(lineGeo, lineMaterial);
  scene.add(lineSegments);

  camera.position.z = 15;

  let targetRotation = new THREE.Vector2();
  window.addEventListener('mousemove', (e) => {
    targetRotation.x = (e.clientY / window.innerHeight - 0.5) * Math.PI;
    targetRotation.y = (e.clientX / window.innerWidth - 0.5) * Math.PI;
  });

  function animate() {
    requestAnimationFrame(animate);
    points.rotation.x += (targetRotation.x - points.rotation.x) * 0.05;
    points.rotation.y += (targetRotation.y - points.rotation.y) * 0.05;
    lineSegments.rotation.x = points.rotation.x;
    lineSegments.rotation.y = points.rotation.y;
    renderer.render(scene, camera);
  }

  animate();
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
