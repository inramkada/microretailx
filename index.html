<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MICRORETAILX</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
    canvas{display:block;width:100vw;height:100vh}
    #hud{
      position:fixed;left:10px;top:10px;z-index:9999;
      font:12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color:#fff;background:rgba(0,0,0,.55);padding:8px 10px;border:1px solid rgba(255,255,255,.15);
      border-radius:10px;backdrop-filter:blur(8px);pointer-events:none;white-space:pre;
    }
    .ui-layer{position:fixed;inset:0;pointer-events:none;z-index:10}
    .top-bar{
      position:absolute;top:0;left:0;right:0;padding:14px 18px;
      background:rgba(0,0,0,.78);border-bottom:1px solid rgba(255,255,255,.1);backdrop-filter:blur(10px);
    }
    .brand{font:900 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      letter-spacing:4px;opacity:.92;color:rgba(255,255,255,.92);mix-blend-mode:difference}
    .footer-bar{
      position:absolute;bottom:0;left:0;right:0;padding:14px 18px 12px;
      background:rgba(0,0,0,.78);border-top:1px solid rgba(255,255,255,.1);backdrop-filter:blur(10px);
      display:flex;flex-direction:column;align-items:center;gap:8px;pointer-events:auto
    }
    .footer-links{display:flex;gap:22px;font:11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;letter-spacing:2px;opacity:.65}
    .footer-links a{color:#fff;text-decoration:none;opacity:.75;pointer-events:auto}
    .footer-links a:hover{opacity:1;text-decoration:underline}
    .copyright{font:9px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;letter-spacing:1px;opacity:.45}
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="hud">BOOT…</div>

  <div class="ui-layer">
    <div class="top-bar"><div class="brand">MICRORETAILX</div></div>
    <div class="footer-bar">
      <div class="footer-links">
        <a href="terms.html">TERMS</a>
        <a href="privacy.html">PRIVACY</a>
        <a href="cookies.html">COOKIES</a>
        <a href="legal.html">LEGAL</a>
      </div>
      <div class="copyright">© 2023–2026 MICRORETAILX LLC. ALL RIGHTS RESERVED.</div>
    </div>
  </div>

<script>
(() => {
  const hud = document.getElementById("hud");
  const log = (s) => hud.textContent = s;

  window.addEventListener("error", (e) => {
    log("JS ERROR:\n" + (e.message || "unknown") + "\n" + (e.filename||"") + ":" + (e.lineno||"") );
  });

  try {
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha:false });

    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;
    const ease=t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2;

    function hsv2rgb(h,s,v){
      h=((h%1)+1)%1;
      const i=Math.floor(h*6), f=h*6-i;
      const p=v*(1-s), q=v*(1-f*s), t=v*(1-(1-f)*s);
      let r,g,b;
      switch(i%6){case 0:r=v;g=t;b=p;break;case 1:r=q;g=v;b=p;break;case 2:r=p;g=v;b=t;break;
        case 3:r=p;g=q;b=v;break;case 4:r=t;g=p;b=v;break;case 5:r=v;g=p;b=q;break;}
      return [(r*255)|0,(g*255)|0,(b*255)|0];
    }

    let W=0,H=0,dpr=1;
    const sim = document.createElement("canvas");
    const sctx = sim.getContext("2d");
    let simW=0, simH=0;
    let trailA, trailB, xField, imgData, img;

    const IS_MOBILE=/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent||"");
    const CFG={
      gridMax: IS_MOBILE?560:860,

      // particles
      pCount: IS_MOBILE?1300:2200,
      pSpeed: IS_MOBILE?0.55:0.75,

      // build
      absorbRampMs: 1000,

      // slime
      aCount: IS_MOBILE?7200:13500,
      step: IS_MOBILE?0.95:1.08,
      sensorDist: IS_MOBILE?6.5:7.9,
      sensorAngle: 0.55,
      turnSpeed: 0.34,
      deposit: 0.95,
      decay: IS_MOBILE?0.973:0.979,
      diffuseEvery: 2,
      diffuseMix: 0.42,

      // X body
      xBias: 0.95,
      xWidthPx: IS_MOBILE?5.3:7.2,
      xInk: 0.42,

      // screen glow
      xStrokeCore: IS_MOBILE?4.6:6.6,
      xStrokeGlow: IS_MOBILE?16:22,

      crush: 0.028
    };

    let particles=[], agents=[];
    let started=false, startAt=0, absorption=0, xComplete=0;
    let lastFrame=performance.now(), frame=0;

    function idx(x,y){ return x + y*simW; }

    function resize(){
      dpr = Math.min(2, window.devicePixelRatio||1);
      W=innerWidth|0; H=innerHeight|0;
      canvas.width=(W*dpr)|0; canvas.height=(H*dpr)|0;
      canvas.style.width=W+"px"; canvas.style.height=H+"px";
      ctx.setTransform(dpr,0,0,dpr,0,0);

      const maxSide=CFG.gridMax;
      const aspect=W/Math.max(1,H);
      if(W>=H){ simW=maxSide; simH=Math.max(180,(maxSide/aspect)|0); }
      else { simH=maxSide; simW=Math.max(180,(maxSide*aspect)|0); }

      sim.width=simW; sim.height=simH;

      const n=simW*simH;
      trailA=new Float32Array(n);
      trailB=new Float32Array(n);
      xField=new Float32Array(n);
      imgData=sctx.createImageData(simW,simH);
      img=imgData.data;

      buildXField();
      seedAgents();
      seedParticles();
    }
    addEventListener("resize", resize);

    function buildXField(){
      const a=(simH-1)/Math.max(1,(simW-1));
      const inv=1/Math.sqrt(1+a*a);
      const sigma=CFG.xWidthPx, sigma2=sigma*sigma;

      for(let y=0;y<simH;y++){
        for(let x=0;x<simW;x++){
          const d1=Math.abs(a*x - y)*inv;
          const d2=Math.abs(a*x + y - (simH-1))*inv;
          const d=Math.min(d1,d2);
          xField[idx(x,y)] = Math.exp(-(d*d)/(2*sigma2));
        }
      }
    }

    function seedParticles(){
      particles.length=0;
      for(let i=0;i<CFG.pCount;i++){
        particles.push({
          x:Math.random()*W, y:Math.random()*H,
          vx:(Math.random()-0.5)*CFG.pSpeed*2,
          vy:(Math.random()-0.5)*CFG.pSpeed*2
        });
      }
    }

    function seedAgents(){
      agents.length=0;
      for(let i=0;i<CFG.aCount;i++){
        let x,y,tries=0;
        while(true){
          x=(Math.random()*simW)|0; y=(Math.random()*simH)|0;
          const xf=xField[idx(x,y)];
          if(Math.random()<(0.14+0.86*xf) || tries++>10) break;
        }
        agents.push({ x:x+Math.random(), y:y+Math.random(), a:Math.random()*Math.PI*2 });
      }
    }

    function diffuse(src,dst,mix){
      for(let y=1;y<simH-1;y++){
        const row=y*simW;
        for(let x=1;x<simW-1;x++){
          const k=row+x;
          const v = src[k] +
            src[k-1]+src[k+1] + src[k-simW]+src[k+simW] +
            src[k-simW-1]+src[k-simW+1] + src[k+simW-1]+src[k+simW+1];
          const blur=v/9;
          dst[k]=src[k]*(1-mix)+blur*mix;
        }
      }
      // borders
      for(let x=0;x<simW;x++){ dst[x]=src[x]; dst[x+(simH-1)*simW]=src[x+(simH-1)*simW]; }
      for(let y=0;y<simH;y++){ dst[y*simW]=src[y*simW]; dst[(simW-1)+y*simW]=src[(simW-1)+y*simW]; }
    }

    function depositAt(x,y,amt){
      const xi=x|0, yi=y|0;
      if(xi<0||yi<0||xi>=simW||yi>=simH) return;
      const k=idx(xi,yi);
      trailA[k]=Math.min(1, trailA[k]+amt);
    }
    function sample(f,x,y){
      const xi=x|0, yi=y|0;
      if(xi<0||yi<0||xi>=simW||yi>=simH) return 0;
      return f[idx(xi,yi)];
    }

    function snapToX(x,y){
      const a=(simH-1)/Math.max(1,(simW-1));
      const y1=a*x;
      const y2=(simH-1)-a*x;
      return Math.abs(y-y1) < Math.abs(y-y2) ? {x,y:y1}:{x,y:y2};
    }

    function inkX(amount){
      for(let y=0;y<simH;y++){
        for(let x=0;x<simW;x++){
          const xf=xField[idx(x,y)];
          if(xf>0.10) trailA[idx(x,y)]=Math.max(trailA[idx(x,y)], amount*xf);
        }
      }
    }

    function stepParticles(dt){
      if(started){
        const t=performance.now()-startAt;
        absorption=clamp(t/CFG.absorbRampMs,0,1);
      }
      for(const p of particles){
        if(absorption>0){
          const sx=(p.x/W)*simW, sy=(p.y/H)*simH;
          const s=snapToX(sx,sy);
          const tx=(s.x/simW)*W, ty=(s.y/simH)*H;
          p.vx += (tx-p.x) * (0.0025 + 0.0105*absorption);
          p.vy += (ty-p.y) * (0.0025 + 0.0105*absorption);
          depositAt(s.x,s.y, 0.10 + 0.28*absorption);
        }
        p.x += p.vx*dt*0.06;
        p.y += p.vy*dt*0.06;

        if(p.x<0) p.x+=W; else if(p.x>=W) p.x-=W;
        if(p.y<0) p.y+=H; else if(p.y>=H) p.y-=H;
      }
    }

    function stepSlime(){
      const sd=CFG.sensorDist, sa=CFG.sensorAngle, turn=CFG.turnSpeed, step=CFG.step;
      for(const p of agents){
        const la=p.a-sa, ra=p.a+sa;
        const fx=p.x+Math.cos(p.a)*sd, fy=p.y+Math.sin(p.a)*sd;
        const lx=p.x+Math.cos(la)*sd, ly=p.y+Math.sin(la)*sd;
        const rx=p.x+Math.cos(ra)*sd, ry=p.y+Math.sin(ra)*sd;

        let fF=sample(trailA,fx,fy), fL=sample(trailA,lx,ly), fR=sample(trailA,rx,ry);
        fF += CFG.xBias*sample(xField,fx,fy);
        fL += CFG.xBias*sample(xField,lx,ly);
        fR += CFG.xBias*sample(xField,rx,ry);

        if(fL>fR && fL>fF) p.a -= turn;
        else if(fR>fL && fR>fF) p.a += turn;
        else if(!(fF>fL && fF>fR)) p.a += (Math.random()-0.5)*0.15;

        p.x += Math.cos(p.a)*step;
        p.y += Math.sin(p.a)*step;

        if(p.x<0) p.x+=simW; else if(p.x>=simW) p.x-=simW;
        if(p.y<0) p.y+=simH; else if(p.y>=simH) p.y-=simH;

        depositAt(p.x,p.y,CFG.deposit);
      }

      for(let k=0;k<trailA.length;k++) trailA[k]*=CFG.decay;

      if((frame%CFG.diffuseEvery)===0){
        diffuse(trailA,trailB,CFG.diffuseMix);
        const tmp=trailA; trailA=trailB; trailB=tmp;
      }
    }

    function scoreX(){
      const samples = IS_MOBILE?80:120;
      let acc=0;
      for(let i=0;i<samples;i++){
        const t=i/(samples-1);
        const x=t*(simW-1);
        const y1=t*(simH-1);
        const y2=(simH-1)-y1;
        const k1=idx(x|0,y1|0), k2=idx(x|0,y2|0);
        const v1=trailA[k1]*(0.55+0.45*xField[k1]);
        const v2=trailA[k2]*(0.55+0.45*xField[k2]);
        acc += clamp(v1,0,1)+clamp(v2,0,1);
      }
      const raw=acc/(samples*2);
      xComplete = lerp(xComplete, clamp(raw*1.25,0,1), 0.08);
    }

    function render(now){
      // particles layer (cyan base)
      ctx.fillStyle="#000";
      ctx.fillRect(0,0,W,H);

      ctx.save();
      ctx.globalCompositeOperation="lighter";
      const t=now*0.001;
      const baseHue=0.52 + 0.06*Math.sin(t*1.2);
      const [pr,pg,pb]=hsv2rgb(baseHue,0.9,1.0);

      for(const p of particles){
        const r=1.0+absorption*0.9;
        const a=0.18+absorption*0.40;
        ctx.fillStyle=`rgba(${pr},${pg},${pb},${a})`;
        ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill();
      }

      // If started, draw maze on top (blend in)
      if(started){
        // render slime texture
        const n=simW*simH;
        const unlock=ease(clamp(xComplete,0,1));
        const H0 = 0.52 + unlock*(0.55*Math.sin(t*1.35) + 0.25*Math.sin(t*3.2));

        for(let k=0,pp=0;k<n;k++,pp+=4){
          const tr=trailA[k];
          const v=tr<=0?0:Math.pow(clamp(tr,0,1),0.62);
          const xf=xField[k];
          const c=clamp(v*(0.82+0.38*xf),0,1);
          const x=(k%simW), y=(k/simW)|0;
          const wave=Math.sin((x*0.035+y*0.028)+t*(1.2+2.4*unlock));
          const wave2=Math.sin((x*0.018-y*0.021)+t*(2.1+3.8*unlock));
          const ir=(0.5+0.5*wave)*(0.35+0.65*unlock) + (0.5+0.5*wave2)*0.18*unlock;
          const hue=H0 + 0.22*ir + 0.10*xf*unlock;
          const [r,g,b]=hsv2rgb(hue,0.92,clamp(0.10+1.15*c,0,1));
          const hot=Math.pow(c,0.42)*(0.20+0.32*xf);
          const on = c < CFG.crush ? 0 : 1;
          img[pp+0]=on?clamp(r+255*hot,0,255)|0:0;
          img[pp+1]=on?clamp(g+255*hot*0.55,0,255)|0:0;
          img[pp+2]=on?clamp(b+255*hot*0.85,0,255)|0:0;
          img[pp+3]=255;
        }
        sctx.putImageData(imgData,0,0);

        const blend=clamp((performance.now()-startAt-550)/800,0,1);
        ctx.globalAlpha = ease(blend);
        ctx.drawImage(sim,0,0,simW,simH,0,0,W,H);
        ctx.globalAlpha = 1;

        // fat X neon body
        const unlock2=ease(clamp(xComplete,0,1));
        const hueX=0.52 + unlock2*(0.55*Math.sin(t*1.35) + 0.20*Math.sin(t*4.8));
        const [xr,xg,xb]=hsv2rgb(hueX,0.95,1.0);
        const alpha=clamp(0.14+0.62*unlock2,0,0.85);

        ctx.strokeStyle=`rgba(${xr},${xg},${xb},${alpha*0.35})`;
        ctx.lineWidth=CFG.xStrokeGlow; ctx.lineCap="round";
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(W,H); ctx.moveTo(W,0); ctx.lineTo(0,H); ctx.stroke();

        ctx.strokeStyle=`rgba(${xr},${xg},${xb},${alpha})`;
        ctx.lineWidth=CFG.xStrokeCore;
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(W,H); ctx.moveTo(W,0); ctx.lineTo(0,H); ctx.stroke();
      }

      ctx.restore();
    }

    // CLICK starts – capture phase so nothing lo bloquea
    window.addEventListener("pointerdown", (e) => {
      // ignore link clicks
      const el = document.elementFromPoint(e.clientX,e.clientY);
      const a = el && el.closest ? el.closest("a") : null;
      if (a) return;

      if(!started){
        started=true;
        startAt=performance.now();
        absorption=0; xComplete=0;
        inkX(0.62);
      } else {
        inkX(0.22);
      }

      // deposit at click snapped to X (so se nota SIEMPRE)
      const fx=clamp((e.clientX/W)*simW,0,simW-1);
      const fy=clamp((e.clientY/H)*simH,0,simH-1);
      const s=snapToX(fx,fy);
      depositAt(s.x,s.y, 1.0);

      log("RUNNING ✅\nclick detected ✅\nabsorb=" + absorption.toFixed(2) + "\nX=" + xComplete.toFixed(2));
    }, { passive:true, capture:true });

    function loop(now){
      const dt=clamp(now-lastFrame,8,40);
      lastFrame=now;

      stepParticles(dt);

      if(started){
        const t=now-startAt;
        if(t<1100) inkX(CFG.xInk);
        stepSlime();
        if(t>900) scoreX();
        log("RUNNING ✅\nabsorb=" + absorption.toFixed(2) + "\nX=" + xComplete.toFixed(2) + "\nframe=" + frame);
      } else {
        log("WAITING CLICK…\n(if it still does nothing: you are not loading the file you think you are)");
      }

      render(now);
      frame++;
      requestAnimationFrame(loop);
    }

    resize();
    requestAnimationFrame(loop);

  } catch (err) {
    document.getElementById("hud").textContent = "CRASH:\n" + (err && err.message ? err.message : String(err));
  }
})();
</script>
</body>
</html>
