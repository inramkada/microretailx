<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MICRORETAILX</title>

  <meta name="referrer" content="no-referrer">
  <meta http-equiv="Permissions-Policy"
        content="geolocation=(), microphone=(), camera=(), payment=(), usb=()">

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
      color: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
                   "Liberation Mono", "Courier New", monospace;
    }
    canvas { display:block; width:100vw; height:100vh; }

    .ui-layer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 10;
    }

    .top-bar {
      position: absolute;
      top: 0; left: 0; right: 0;
      padding: 14px 18px;
      display: flex;
      justify-content: flex-start;
      background: rgba(0,0,0,0.78);
      border-bottom: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
    }

    /* Brand: cuerpo, sin “efecto propio”, pero se mezcla con lo de atrás */
    .brand {
      font-size: 12px;
      letter-spacing: 4px;
      font-weight: 900;
      opacity: 0.92;
      color: rgba(255,255,255,0.92);
      mix-blend-mode: difference;
      text-shadow: none;
    }

    .footer-bar {
      position: absolute;
      bottom: 0; left: 0; right: 0;
      padding: 14px 18px 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      background: rgba(0,0,0,0.78);
      border-top: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
      pointer-events: auto;
    }

    .footer-links {
      display: flex;
      gap: 22px;
      font-size: 11px;
      letter-spacing: 2px;
      opacity: 0.65;
    }
    .footer-links a {
      color:#fff;
      text-decoration:none;
      opacity:0.75;
      pointer-events:auto;
    }
    .footer-links a:hover { opacity:1; text-decoration: underline; }

    .copyright {
      font-size: 9px;
      letter-spacing: 1px;
      opacity: 0.45;
      text-align: center;
    }

    @media (max-width: 600px) {
      .brand { font-size: 11px; letter-spacing: 3px; }
      .footer-links { flex-wrap: wrap; justify-content:center; gap: 14px; }
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>

  <div class="ui-layer">
    <div class="top-bar">
      <div class="brand">MICRORETAILX</div>
    </div>

    <div class="footer-bar">
      <div class="footer-links">
        <a href="terms.html">TERMS</a>
        <a href="privacy.html">PRIVACY</a>
        <a href="cookies.html">COOKIES</a>
        <a href="legal.html">LEGAL</a>
      </div>
      <div class="copyright">
        © 2023–2026 MICRORETAILX LLC. ALL RIGHTS RESERVED.
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ---------------------------
  //  Physarum / slime-mold sim
  //  - agent trails + diffusion + decay
  //  - X is an invisible “nutrient rail” attractor (two diagonals)
  //  - click drops “food” points
  // ---------------------------

  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d", { alpha: false });

  const UA = navigator.userAgent || "";
  const IS_IOS =
    /iPhone|iPad|iPod/i.test(UA) ||
    (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
  const IS_MOBILE = /Mobi|Android|iPhone|iPad/i.test(UA);

  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  const lerp  = (a,b,t)=> a + (b-a)*t;

  const DPR_CAP = IS_IOS ? 1.6 : 2;
  let dpr = Math.min(DPR_CAP, window.devicePixelRatio || 1);

  let W=0, H=0;
  let simW=0, simH=0, scale=1;

  // simulation fields
  let trailA, trailB;      // Float32Array
  let xField;              // Float32Array (static attractor: the X)
  let imgData, img8;       // ImageData / Uint8ClampedArray
  let agents = [];
  let foods = [];          // {x,y,life,amp}
  let tPrev = performance.now();

  // --- Tunables (balanced for “maze” look) ---
  const CFG = {
    // grid resolution target (smaller = faster, more chunky)
    gridMax: IS_MOBILE ? 520 : 760,

    agentCount: IS_MOBILE ? 5200 : 11000,
    step: IS_MOBILE ? 0.85 : 1.05,

    // sensing
    sensorDist: IS_MOBILE ? 6.0 : 7.5,
    sensorAngle: 0.55,         // radians
    turnSpeed: 0.35,           // radians per step

    // deposition / diffusion / decay
    deposit: 0.92,
    decay: IS_MOBILE ? 0.972 : 0.978,  // closer to 1 = longer persistence
    diffuseEvery: 2,                   // blur pass every N frames
    diffuseMix: 0.40,

    // X attractor influence
    xBias: 0.65,
    xWidthPx: IS_MOBILE ? 2.2 : 2.8,   // thickness of the “rail” (in sim pixels)

    // food attractors
    foodRadius: IS_MOBILE ? 18 : 22,
    foodStrength: 1.4,
    foodLifeMs: 2200,

    // subtle center flash on click
    flashMs: 260,
    flashAmp: 0.55
  };

  let frame = 0;
  let lastFlashAt = 0;
  let flashX = 0, flashY = 0;

  function resize() {
    dpr = Math.min(DPR_CAP, window.devicePixelRatio || 1);
    W = window.innerWidth | 0;
    H = window.innerHeight | 0;

    canvas.width  = (W * dpr) | 0;
    canvas.height = (H * dpr) | 0;
    canvas.style.width  = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // pick sim grid size maintaining aspect
    const maxSide = CFG.gridMax;
    const aspect = W / Math.max(1, H);
    if (W >= H) {
      simW = maxSide;
      simH = Math.max(120, (maxSide / aspect) | 0);
    } else {
      simH = maxSide;
      simW = Math.max(120, (maxSide * aspect) | 0);
    }

    scale = W / simW;

    const n = simW * simH;
    trailA = new Float32Array(n);
    trailB = new Float32Array(n);
    xField = new Float32Array(n);

    imgData = ctx.createImageData(simW, simH);
    img8 = imgData.data;

    buildXField();
    seedAgents(true);
  }

  window.addEventListener("resize", resize);

  function idx(x, y) { return x + y * simW; }

  function buildXField() {
    // Invisible attractor along both diagonals.
    // We precompute “closeness to diagonal” as [0..1].
    // For each pixel: d = min( distance to y = (H/W)x , distance to y = H - (H/W)x )
    // Using sim coordinates (0..simW-1, 0..simH-1).
    const w = simW, h = simH;
    const a = (h - 1) / Math.max(1, (w - 1)); // slope
    const inv = 1 / Math.sqrt(1 + a*a);

    // thickness in sim pixels
    const sigma = CFG.xWidthPx;
    const sigma2 = sigma * sigma;

    for (let y=0; y<h; y++) {
      for (let x=0; x<w; x++) {
        // Distance point to line y = a x   => |ax - y| / sqrt(a^2 + 1)
        const d1 = Math.abs(a*x - y) * inv;
        // Distance to line y = -a x + (h-1)  => |a x + y - (h-1)| / sqrt(a^2 + 1)
        const d2 = Math.abs(a*x + y - (h - 1)) * inv;
        const d = Math.min(d1, d2);

        // gaussian-ish bump -> [0..1]
        const v = Math.exp(-(d*d) / (2*sigma2));
        xField[idx(x,y)] = v;
      }
    }
  }

  function seedAgents(resetTrails=false) {
    if (resetTrails) {
      trailA.fill(0); trailB.fill(0);
    }
    agents.length = 0;

    // Seed agents preferentially near the X “rails”
    // so the system self-organizes as an X-maze network.
    const n = CFG.agentCount;
    for (let i=0; i<n; i++) {
      // rejection sample to bias to higher xField
      let x, y, tries=0;
      while (true) {
        x = (Math.random() * simW) | 0;
        y = (Math.random() * simH) | 0;
        const xf = xField[idx(x,y)];
        if (Math.random() < 0.20 + 0.80*xf || tries++ > 8) break;
      }

      agents.push({
        x: x + Math.random(),
        y: y + Math.random(),
        a: Math.random() * Math.PI * 2
      });
    }
  }

  // --- Food drop (click attractor) ---
  function addFood(px, py) {
    // ignore clicks on legal links
    const el = document.elementFromPoint(px, py);
    const a = el && el.closest ? el.closest("a") : null;
    if (a) return;

    const fx = clamp((px / W) * simW, 0, simW-1);
    const fy = clamp((py / H) * simH, 0, simH-1);

    foods.push({
      x: fx,
      y: fy,
      life: CFG.foodLifeMs,
      amp: 1.0
    });

    lastFlashAt = performance.now();
    flashX = fx; flashY = fy;
  }

  window.addEventListener("pointerdown", (e) => {
    addFood(e.clientX, e.clientY);
  }, { passive:true });

  // --- Sampling helpers ---
  function sampleField(f, x, y) {
    const xi = x | 0, yi = y | 0;
    if (xi < 0 || yi < 0 || xi >= simW || yi >= simH) return 0;
    return f[idx(xi, yi)];
  }

  function depositAt(f, x, y, amt) {
    const xi = x | 0, yi = y | 0;
    if (xi < 0 || yi < 0 || xi >= simW || yi >= simH) return;
    const k = idx(xi, yi);
    f[k] = Math.min(1.0, f[k] + amt);
  }

  // --- One diffusion pass (cheap 3x3 box blur) ---
  function diffuse(src, dst, mix) {
    const w=simW, h=simH;
    // edges: keep simple
    for (let y=1; y<h-1; y++) {
      let row = y*w;
      for (let x=1; x<w-1; x++) {
        const k = row + x;
        const v =
          src[k] +
          src[k-1] + src[k+1] +
          src[k-w] + src[k+w] +
          src[k-w-1] + src[k-w+1] +
          src[k+w-1] + src[k+w+1];

        const blur = v / 9;
        dst[k] = src[k]*(1-mix) + blur*mix;
      }
    }
    // copy border
    for (let x=0; x<w; x++) {
      dst[x] = src[x];
      dst[x + (h-1)*w] = src[x + (h-1)*w];
    }
    for (let y=0; y<h; y++) {
      dst[y*w] = src[y*w];
      dst[(w-1) + y*w] = src[(w-1) + y*w];
    }
  }

  function stepSim(dtMs) {
    // age foods + create a “food field” on the fly when sampling
    for (let i=foods.length-1; i>=0; i--) {
      foods[i].life -= dtMs;
      if (foods[i].life <= 0) foods.splice(i, 1);
      else foods[i].amp = foods[i].life / CFG.foodLifeMs;
    }

    const step = CFG.step;
    const sDist = CFG.sensorDist;
    const sAng  = CFG.sensorAngle;
    const turn  = CFG.turnSpeed;

    // precompute for speed
    const xBias = CFG.xBias;
    const foodStr = CFG.foodStrength;

    // update agents
    for (let i=0; i<agents.length; i++) {
      const p = agents[i];

      // sensor positions
      const ca = Math.cos(p.a), sa = Math.sin(p.a);
      const la = p.a - sAng, ra = p.a + sAng;

      const fx = p.x + ca * sDist, fy = p.y + sa * sDist;
      const lx = p.x + Math.cos(la) * sDist, ly = p.y + Math.sin(la) * sDist;
      const rx = p.x + Math.cos(ra) * sDist, ry = p.y + Math.sin(ra) * sDist;

      // base trail sensing
      let fF = sampleField(trailA, fx, fy);
      let fL = sampleField(trailA, lx, ly);
      let fR = sampleField(trailA, rx, ry);

      // add X attractor (static)
      fF += xBias * sampleField(xField, fx, fy);
      fL += xBias * sampleField(xField, lx, ly);
      fR += xBias * sampleField(xField, rx, ry);

      // add food attractors (dynamic, radial)
      if (foods.length) {
        let addF=0, addL=0, addR=0;
        for (let j=0; j<foods.length; j++) {
          const fd = foods[j];
          const amp = fd.amp;
          const rr = CFG.foodRadius;

          const dxF = fx - fd.x, dyF = fy - fd.y;
          const dxL = lx - fd.x, dyL = ly - fd.y;
          const dxR = rx - fd.x, dyR = ry - fd.y;

          const d2F = dxF*dxF + dyF*dyF;
          const d2L = dxL*dxL + dyL*dyL;
          const d2R = dxR*dxR + dyR*dyR;

          const gF = Math.exp(-d2F / (2*rr*rr)) * amp;
          const gL = Math.exp(-d2L / (2*rr*rr)) * amp;
          const gR = Math.exp(-d2R / (2*rr*rr)) * amp;

          addF += gF; addL += gL; addR += gR;
        }
        fF += foodStr * addF;
        fL += foodStr * addL;
        fR += foodStr * addR;
      }

      // decide turn
      if (fF > fL && fF > fR) {
        // straight
      } else if (fL > fR) {
        p.a -= turn;
      } else if (fR > fL) {
        p.a += turn;
      } else {
        // tie-break noise
        p.a += (Math.random() - 0.5) * 0.15;
      }

      // move
      p.x += Math.cos(p.a) * step;
      p.y += Math.sin(p.a) * step;

      // wrap around (torus)
      if (p.x < 0) p.x += simW;
      else if (p.x >= simW) p.x -= simW;
      if (p.y < 0) p.y += simH;
      else if (p.y >= simH) p.y -= simH;

      // deposit
      depositAt(trailA, p.x, p.y, CFG.deposit);
    }

    // decay
    const d = CFG.decay;
    for (let k=0; k<trailA.length; k++) trailA[k] *= d;

    // diffuse (every N frames)
    if ((frame % CFG.diffuseEvery) === 0) {
      diffuse(trailA, trailB, CFG.diffuseMix);
      // swap
      const tmp = trailA; trailA = trailB; trailB = tmp;
    }
  }

  function render(now) {
    // map trail intensity to a premium cyan/magenta “bioelectric” palette
    // without drawing a literal X: the X only appears if the network forms there.
    const n = simW * simH;

    // center flash after clicks (subtle)
    const fdt = now - lastFlashAt;
    const flash = (fdt >= 0 && fdt < CFG.flashMs)
      ? (1 - (fdt / CFG.flashMs)) * CFG.flashAmp
      : 0;

    for (let k=0, p=0; k<n; k++, p+=4) {
      const t = trailA[k];

      // non-linear curve: enhances filaments, keeps background black-black
      const v = t <= 0 ? 0 : Math.pow(clamp(t, 0, 1), 0.62);

      // tiny chroma wobble driven by xField to give “maze intelligence” shimmer
      const xf = xField[k]; // 0..1
      const c = clamp(v * (0.95 + 0.18*xf), 0, 1);

      // add flash as radial light in render-space
      let add = 0;
      if (flash > 0) {
        const x = (k % simW), y = (k / simW) | 0;
        const dx = x - flashX, dy = y - flashY;
        const r2 = dx*dx + dy*dy;
        add = flash * Math.exp(-r2 / (2 * (CFG.foodRadius*1.4) * (CFG.foodRadius*1.4)));
      }

      const lum = clamp(c + add, 0, 1);

      // “bioelectric” palette:
      // cyan core + faint magenta fringe, still looks good over pure black.
      const r = clamp(  14 + lum*255*0.95 + (xf*lum*55), 0, 255) | 0;
      const g = clamp(  10 + lum*255*0.78, 0, 255) | 0;
      const b = clamp(  18 + lum*255*1.00, 0, 255) | 0;

      // deepen blacks aggressively
      const crush = lum < 0.03 ? 0 : 1;
      img8[p+0] = crush ? r : 0;
      img8[p+1] = crush ? g : 0;
      img8[p+2] = crush ? b : 0;
      img8[p+3] = 255;
    }

    // draw sim texture scaled to full canvas
    ctx.putImageData(imgData, 0, 0);
    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.globalCompositeOperation = "source-over";
    ctx.drawImage(canvas, 0, 0, simW, simH, 0, 0, W, H);
    ctx.restore();

    // hard black letterbox cleanup (ensures “absolute black” background)
    // (in case rounding leaves a 1px edge on some GPUs)
    ctx.save();
    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = "#000";
    // if aspect mismatch causes small uncovered strips, cover them:
    // (safe no-op most of the time)
    ctx.fillRect(W-1, 0, 2, H);
    ctx.fillRect(0, H-1, W, 2);
    ctx.restore();
  }

  function loop(now) {
    const dt = clamp(now - tPrev, 8, 40);
    tPrev = now;

    stepSim(dt);
    render(now);

    frame++;
    requestAnimationFrame(loop);
  }

  resize();
  requestAnimationFrame(loop);

  // Optional: keyboard nuke / reseed for quick iterations
  window.addEventListener("keydown", (e) => {
    if (e.key === "r" || e.key === "R") seedAgents(true);
  });
})();
</script>
</body>
</html>
