<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MICRORETAILX</title>

  <meta name="referrer" content="no-referrer">
  <meta http-equiv="Permissions-Policy"
        content="geolocation=(), microphone=(), camera=(), payment=(), usb=()">

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
      color: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
                   "Liberation Mono", "Courier New", monospace;
    }
    canvas { display:block; width:100vw; height:100vh; }

    .ui-layer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 10;
    }

    .top-bar {
      position: absolute;
      top: 0; left: 0; right: 0;
      padding: 14px 18px;
      display: flex;
      justify-content: flex-start;
      background: rgba(0,0,0,0.78);
      border-bottom: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
    }

    /* Body + “transparent RGB to backgrounds” */
    .brand {
      font-size: 12px;
      letter-spacing: 4px;
      font-weight: 800;
      opacity: 0.92;
      color: rgba(255,255,255,0.92);
      mix-blend-mode: difference;
      text-shadow: none;
    }

    .footer-bar {
      position: absolute;
      bottom: 0; left: 0; right: 0;
      padding: 14px 18px 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      background: rgba(0,0,0,0.78);
      border-top: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
      pointer-events: auto;
    }

    .footer-links {
      display: flex;
      gap: 22px;
      font-size: 11px;
      letter-spacing: 2px;
      opacity: 0.65;
    }
    .footer-links a {
      color:#fff;
      text-decoration:none;
      opacity:0.75;
      pointer-events:auto;
    }
    .footer-links a:hover { opacity:1; text-decoration: underline; }

    .copyright {
      font-size: 9px;
      letter-spacing: 1px;
      opacity: 0.45;
      text-align: center;
    }

    @media (max-width: 600px) {
      .brand { font-size: 11px; letter-spacing: 3px; }
      .footer-links { flex-wrap: wrap; justify-content:center; gap: 14px; }
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>

  <div class="ui-layer">
    <div class="top-bar">
      <div class="brand">MICRORETAILX</div>
    </div>

    <div class="footer-bar">
      <div class="footer-links">
        <a href="terms.html">TERMS</a>
        <a href="privacy.html">PRIVACY</a>
        <a href="cookies.html">COOKIES</a>
        <a href="legal.html">LEGAL</a>
      </div>
      <div class="copyright">
        © 2023–2026 MICRORETAILX LLC. ALL RIGHTS RESERVED.
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d", { alpha: false });

  const UA = navigator.userAgent || "";
  const IS_IOS =
    /iPhone|iPad|iPod/i.test(UA) ||
    (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
  const IS_MOBILE = /Mobi|Android|iPhone|iPad/i.test(UA);

  const DPR_CAP = IS_IOS ? 1.6 : 2;
  let dpr = Math.min(DPR_CAP, window.devicePixelRatio || 1);

  let W = 0, H = 0;

  function resize() {
    dpr = Math.min(DPR_CAP, window.devicePixelRatio || 1);
    W = window.innerWidth | 0;
    H = window.innerHeight | 0;
    canvas.width = (W * dpr) | 0;
    canvas.height = (H * dpr) | 0;
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener("resize", resize);

  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  const lerp  = (a,b,t)=> a + (b-a)*t;
  const ease  = t => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;

  function hash01(x, y){
    // deterministic "random" in [0,1)
    const s = Math.sin(x*12.9898 + y*78.233) * 43758.5453;
    return s - Math.floor(s);
  }

  function glow(x, y, r, a, rgb) {
    if (a <= 0) return;
    const c = rgb || { r:0, g:234, b:255 };
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    const g = ctx.createRadialGradient(x, y, 0, x, y, r);
    g.addColorStop(0, `rgba(${c.r},${c.g},${c.b},${a})`);
    g.addColorStop(0.35, `rgba(${c.r},${c.g},${c.b},${a*0.35})`);
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
  }

  function drawX(alpha){
    ctx.save();
    ctx.strokeStyle = `rgba(0,234,255,${alpha})`;
    ctx.lineWidth = 1.7;
    ctx.beginPath();
    ctx.moveTo(0, 0); ctx.lineTo(W, H);
    ctx.moveTo(W, 0); ctx.lineTo(0, H);
    ctx.stroke();

    ctx.strokeStyle = `rgba(0,234,255,${alpha * 0.55})`;
    ctx.lineWidth = 3.2;
    ctx.beginPath();
    ctx.moveTo(0, 0); ctx.lineTo(W, H);
    ctx.moveTo(W, 0); ctx.lineTo(0, H);
    ctx.stroke();
    ctx.restore();
  }

  function drawFiber(x1, y1, x2, y2, a, amp){
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.lineCap = "round";
    ctx.lineWidth = 1.1 + 1.4 * amp;
    ctx.strokeStyle = `rgba(0,234,255,${a * 0.10 * amp})`;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    ctx.lineWidth = 0.75;
    ctx.strokeStyle = `rgba(255,255,255,${a * 0.05 * amp})`;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    ctx.restore();
  }

  function drawCloudHead(x, y, a, amp, bias){
    // big soft cloud
    glow(x, y, (IS_MOBILE? 84: 96) * (0.85 + 0.35*amp), a * 0.14 * amp, { r:0, g:234, b:255 });
    // secondary purple tint (bias controls how much)
    glow(x, y, (IS_MOBILE? 60: 70) * (0.9 + 0.4*amp), a * 0.08 * amp * bias, { r:120, g:0, b:255 });
    // inner hot point
    glow(x, y, (IS_MOBILE? 22: 26) * (0.85 + 0.5*amp), a * 0.14 * amp, { r:255, g:255, b:255 });
    // tiny magenta rim occasionally
    glow(x, y, (IS_MOBILE? 38: 44) * (0.85 + 0.4*amp), a * 0.05 * amp * bias, { r:255, g:20, b:90 });
  }

  // ---- Sequence state ----
  const seq = {
    active: false,
    t0: 0,
    amp: 0.0,
    phi: 0.0,
    mode: 0,
    spin: 0.0,
    skew: 0.0,
    burst: 0.0
  };

  const COOLDOWN_MS = 900;
  let nextAllowed = 0;

  // timings (seconds)
  const BASE_IN   = IS_MOBILE ? 0.78 : 0.72;
  const BASE_FLASH= 0.18;
  const BASE_HOLD = 0.22;
  const BASE_OUT  = IS_MOBILE ? 0.62 : 0.56;

  function startSequence(x, y) {
    const now = performance.now();
    if (now < nextAllowed) return;
    nextAllowed = now + COOLDOWN_MS;

    const cx = W/2, cy = H/2;
    const dx = x - cx, dy = y - cy;
    const d = Math.sqrt(dx*dx + dy*dy);
    const maxD = Math.min(W, H) * 0.55;
    const near = clamp(1 - d / maxD, 0, 1);
    const amp = 0.35 + 0.65 * (near * near);

    const h = hash01(x, y);
    const mode = (h * 3) | 0;          // 0..2
    const spin = (hash01(y, x) * 2 - 1) * (IS_MOBILE ? 0.12 : 0.16); // subtle curvature
    const skew = (hash01(x+13, y+7) * 2 - 1) * 0.08;                 // asymmetry
    const burst = (hash01(x+101, y+17) < 0.35) ? (0.15 + 0.35*hash01(x+5,y+9)) : 0.0;

    const phi = (x * 0.017 + y * 0.013) % (Math.PI * 2);

    seq.active = true;
    seq.t0 = now;
    seq.amp = amp;
    seq.phi = phi;
    seq.mode = mode;
    seq.spin = spin;
    seq.skew = skew;
    seq.burst = burst;
  }

  window.addEventListener("pointerdown", (e) => {
    const a = e.target && e.target.closest && e.target.closest("a");
    if (a) return;
    startSequence(e.clientX, e.clientY);
  }, { passive: true });

  function renderSequence(now) {
    if (!seq.active) return;

    // mode shapes timings slightly, so it doesn't repeat
    const IN_DUR    = BASE_IN   * (seq.mode === 0 ? 1.00 : seq.mode === 1 ? 0.92 : 1.06);
    const FLASH_DUR = BASE_FLASH* (seq.mode === 2 ? 1.08 : 1.00);
    const HOLD_DUR  = BASE_HOLD * (seq.mode === 1 ? 0.85 : 1.00);
    const OUT_DUR   = BASE_OUT  * (seq.mode === 0 ? 1.00 : seq.mode === 2 ? 0.92 : 1.05);
    const total = IN_DUR + FLASH_DUR + HOLD_DUR + OUT_DUR;

    const t = (now - seq.t0) / 1000;
    if (t >= total) { seq.active = false; return; }

    // subtle persistence while active = volumetric "nube"
    ctx.save();
    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = `rgba(0,0,0,${IS_MOBILE ? 0.20 : 0.16})`;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    const cx = W/2, cy = H/2;
    const corners = [
      { x:0, y:0 },
      { x:W, y:0 },
      { x:0, y:H },
      { x:W, y:H }
    ];

    const amp = seq.amp;
    const bias = 0.55 + 0.45 * (0.5 - 0.5 * Math.cos(seq.phi + now*0.001));

    // Inbound
    if (t < IN_DUR) {
      const p = ease(t / IN_DUR);

      for (let i=0;i<corners.length;i++){
        const o = corners[i];

        // curvature: bend towards diagonal based on spin & corner id
        const bend = seq.spin * (i%2===0 ? 1 : -1);
        const midx = lerp(o.x, cx, p) + bend * (H*0.12) * Math.sin(p*Math.PI);
        const midy = lerp(o.y, cy, p) - bend * (W*0.12) * Math.sin(p*Math.PI);

        // asymmetry: skew cloud size slightly
        const skew = 1 + seq.skew * (i<2 ? 1 : -1);

        // trail: multiple ghost heads
        const steps = IS_MOBILE ? 12 : 18;
        const span = 0.20;
        for (let k=0;k<steps;k++){
          const kk = k / steps;
          const tt = clamp(p - kk*span, 0, 1);
          const q = ease(tt);

          const tx = lerp(o.x, cx, q) + bend * (H*0.12) * Math.sin(q*Math.PI);
          const ty = lerp(o.y, cy, q) - bend * (W*0.12) * Math.sin(q*Math.PI);

          const fade = (1 - kk);
          drawCloudHead(tx, ty, 0.80 * fade, amp * skew, bias);
        }

        // fiber from origin to head (thin, premium)
        drawFiber(o.x, o.y, midx, midy, 0.9, amp);

        // head
        drawCloudHead(midx, midy, 1.0, amp * skew, bias);
      }
      return;
    }

    // Center flash
    const t1 = t - IN_DUR;
    if (t1 < FLASH_DUR) {
      const u = t1 / FLASH_DUR;
      const p = 1 - ease(u); // strong at start then down

      const flashA = (0.24 * amp) * (1 - p);
      glow(cx, cy, Math.min(W,H) * 0.26, flashA * 0.20, { r:0, g:234, b:255 });
      glow(cx, cy, Math.min(W,H) * 0.16, flashA * 0.14, { r:120, g:0, b:255 });
      glow(cx, cy, Math.min(W,H) * 0.09, flashA * 0.10, { r:255, g:255, b:255 });

      // optional burst (not always)
      if (seq.burst > 0.0 && u < 0.5) {
        glow(cx, cy, Math.min(W,H) * 0.34, flashA * 0.10 * seq.burst, { r:255, g:20, b:90 });
      }

      // hint X briefly
      drawX(0.07 * amp * (1 - p));
      return;
    }

    // Hold X
    const t2 = t1 - FLASH_DUR;
    if (t2 < HOLD_DUR) {
      const holdP = t2 / HOLD_DUR;
      const a = 0.18 * amp * (1 - 0.62*holdP);
      glow(cx, cy, Math.min(W,H) * 0.18, 0.07 * amp);
      drawX(a);
      return;
    }

    // Outbound release
    const t3 = t2 - HOLD_DUR;
    const pOut = ease(t3 / OUT_DUR);
    const p = 1 - pOut;

    for (let i=0;i<corners.length;i++){
      const o = corners[i];

      const bend = seq.spin * (i%2===0 ? 1 : -1);
      const x = lerp(o.x, cx, p) + bend * (H*0.12) * Math.sin(p*Math.PI);
      const y = lerp(o.y, cy, p) - bend * (W*0.12) * Math.sin(p*Math.PI);

      const fadeA = (1 - pOut);
      const skew = 1 + seq.skew * (i<2 ? 1 : -1);

      // trail
      const steps = IS_MOBILE ? 10 : 14;
      const span = 0.18;
      for (let k=0;k<steps;k++){
        const kk = k / steps;
        const tt = clamp(p - kk*span, 0, 1);
        const q = ease(tt);

        const tx = lerp(o.x, cx, q) + bend * (H*0.12) * Math.sin(q*Math.PI);
        const ty = lerp(o.y, cy, q) - bend * (W*0.12) * Math.sin(q*Math.PI);

        const fade = (1 - kk) * fadeA;
        drawCloudHead(tx, ty, 0.55 * fade, amp * skew, bias);
      }

      // fiber from head to center
      drawFiber(x, y, cx, cy, 0.65 * fadeA, amp);

      drawCloudHead(x, y, 0.85 * fadeA, amp * skew, bias);
    }
  }

  function loop(now){
    if (!seq.active) {
      // absolute black idle
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,W,H);
    } else {
      renderSequence(now);
    }
    requestAnimationFrame(loop);
  }

  resize();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
