<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>microretailX — Life / X</title>

  <!-- NOTE:
       If you already set CSP in Cloudflare RESPONSE HEADERS, remove this meta CSP to avoid conflicts. -->
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self';
                 script-src 'self' 'unsafe-inline';
                 style-src 'self' 'unsafe-inline';
                 img-src 'self' data:;
                 font-src 'self';
                 connect-src 'self';
                 base-uri 'self';
                 frame-ancestors 'none';
                 form-action 'self'">

  <meta name="referrer" content="no-referrer">
  <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=(), payment=(), usb=()">

  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: #fff;
    }

    canvas { display:block; width:100vw; height:100vh; }

    .ui {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 10;
    }

    .top {
      position: absolute;
      top: 0; left: 0; right: 0;
      padding: 14px 18px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(0,0,0,0.78);
      border-bottom: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
    }

    .brand {
      letter-spacing: 3px;
      font-size: 12px;
      opacity: .9;
      text-transform: uppercase;
      white-space: nowrap;
    }

    .status {
      font-size: 11px;
      letter-spacing: 1px;
      opacity: .65;
      text-align: right;
      line-height: 1.35;
      white-space: nowrap;
    }

    .footer {
      position: absolute;
      left: 0; right: 0; bottom: 0;
      padding: 10px 18px 12px;
      display:flex;
      justify-content: space-between;
      align-items: flex-end;
      background: rgba(0,0,0,0.78);
      border-top: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
      gap: 14px;
      pointer-events: auto;
    }

    .footer-links{
      display:flex; flex-wrap:wrap; gap: 10px;
      font-size: 11px;
      letter-spacing: 1px;
      opacity: .85;
      text-transform: uppercase;
    }

    .footer-links a{
      color:#fff; text-decoration:none; opacity:.85;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      padding: 7px 10px;
      border-radius: 12px;
    }
    .footer-links a:hover{ opacity:1; box-shadow: 0 0 18px rgba(255,255,255,0.10); }

    .help {
      font-size: 10px;
      letter-spacing: 1px;
      opacity: .55;
      line-height: 1.5;
      pointer-events: none;
    }

    .kbd {
      display:inline-block;
      padding: 1px 6px;
      border: 1px solid rgba(255,255,255,0.18);
      border-bottom-color: rgba(255,255,255,0.28);
      border-radius: 8px;
      background: rgba(255,255,255,0.06);
      opacity: .9;
      margin: 0 2px;
    }

    @media (max-width: 720px){
      .status { display:none; }
      .footer { flex-direction: column; align-items: stretch; }
      .footer-links{ justify-content: center; }
      .help{ text-align:center; }
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>

  <div class="ui">
    <div class="top">
      <div class="brand">microretailX / LIFE · X</div>
      <div class="status" id="status">RUNNING · 12/s<br/>cells: —</div>
    </div>

    <div class="footer">
      <div class="help">
        Paint: click/drag · Pause: <span class="kbd">Space</span> · Random: <span class="kbd">R</span> · Clear: <span class="kbd">C</span><br/>
        Speed: <span class="kbd">+</span>/<span class="kbd">-</span> · Brush: <span class="kbd">1</span>/<span class="kbd">2</span>/<span class="kbd">3</span>
      </div>

      <div class="footer-links">
        <a href="terms.html">Terms</a>
        <a href="privacy.html">Privacy</a>
        <a href="cookies.html">Cookies</a>
        <a href="legal.html">Legal</a>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });
  const statusEl = document.getElementById("status");

  // -------- Perf & device --------
  const UA = navigator.userAgent || "";
  const IS_IOS = /iPhone|iPad|iPod/i.test(UA) || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
  const IS_MOBILE = /Mobi|Android|iPhone|iPad/i.test(UA);
  const REDUCED = window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;

  // Cap DPR to avoid heavy fill on retina
  const DPR_CAP = IS_IOS ? 1.6 : 2;
  let dpr = Math.min(DPR_CAP, window.devicePixelRatio || 1);

  // FPS cap on iOS/mobile (prevents heat)
  const TARGET_FPS = (IS_IOS || IS_MOBILE) ? 30 : 60;
  let lastFrameMs = 0;

  // -------- Helpers --------
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  const ease = t => t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
  const pulse = t => 0.5 - 0.5 * Math.cos(Math.PI * clamp(t, 0, 1));
  const lerp = (a,b,t)=> a + (b-a)*t;

  // -------- Canvas sizing --------
  let W = 0, H = 0;

  function resize() {
    dpr = Math.min(DPR_CAP, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);

    canvas.width  = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // reinit Life buffers on resize
    initLife();
  }
  window.addEventListener("resize", resize);

  // ==========================================================
  // 1) X PULSE (adapted from your fondo-legal-xpulse.js)
  // ==========================================================
  let xt = 0;
  let xLast = performance.now();

  const X_IN = 2.8;
  const X_HOLD = 1.15;
  const X_OUT = 2.2;
  const X_REST = 0.55;
  const X_CYCLE = X_IN + X_HOLD + X_OUT + X_REST;

  function glow(x, y, r, a, rgb) {
    if (a <= 0) return;
    const c = rgb || { r:0, g:234, b:255 };
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    const g = ctx.createRadialGradient(x, y, 0, x, y, r);
    g.addColorStop(0, `rgba(${c.r},${c.g},${c.b},${a})`);
    g.addColorStop(0.35, `rgba(${c.r},${c.g},${c.b},${a * 0.35})`);
    g.addColorStop(1, `rgba(${c.r},${c.g},${c.b},0)`);
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawX(alpha) {
    ctx.save();
    ctx.strokeStyle = `rgba(0,234,255,${alpha})`;
    ctx.lineWidth = 1.7;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(W, H);
    ctx.moveTo(W, 0);
    ctx.lineTo(0, H);
    ctx.stroke();

    ctx.strokeStyle = `rgba(0,234,255,${alpha * 0.52})`;
    ctx.lineWidth = 3.2;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(W, H);
    ctx.moveTo(W, 0);
    ctx.lineTo(0, H);
    ctx.stroke();
    ctx.restore();
  }

  // "Energy" fed by Life reaching the X: boosts line glow + center pulse
  let xEnergy = 0; // 0..~1
  function feedXEnergy(amount) {
    xEnergy = clamp(xEnergy + amount, 0, 1.25);
  }

  function renderXPulse(now) {
    const dt = Math.min(0.05, (now - xLast) / 1000);
    xLast = now;
    xt = (xt + dt) % X_CYCLE;

    // energy decay (keep it alive but not permanent)
    xEnergy *= 0.985;

    const cx = W / 2;
    const cy = H / 2;

    const tin = clamp(xt / X_IN, 0, 1);
    const th = clamp((xt - X_IN) / X_HOLD, 0, 1);
    const tout = clamp((xt - X_IN - X_HOLD) / X_OUT, 0, 1);

    const inA = xt < X_IN;
    const holdA = xt >= X_IN && xt < X_IN + X_HOLD;
    const outA = xt >= X_IN + X_HOLD && xt < X_IN + X_HOLD + X_OUT;

    const baseA = 0.045;
    let lineA = baseA;
    if (inA) lineA += 0.08 * pulse(tin);
    if (holdA) lineA += 0.18 * pulse(th);
    if (outA) lineA += 0.14 * (1 - pulse(tout));

    // energy boost makes the X more "alive"
    lineA += 0.10 * xEnergy;

    drawX(lineA);

    const origins = [
      { x: 0, y: 0 },
      { x: W, y: 0 },
      { x: 0, y: H },
      { x: W, y: H }
    ];

    const headR = IS_MOBILE ? 52 : 62;
    const tailSteps = IS_MOBILE ? 10 : 14;
    const tailSpan = 0.1;

    function trail(posFn, prog, a) {
      for (const o of origins) {
        const head = posFn(o, prog);
        for (let i = 0; i < tailSteps; i++) {
          const k = i / tailSteps;
          const tt = clamp(prog - k * tailSpan, 0, 1);
          const e = ease(tt);
          const p = posFn(o, e);
          const f = 1 - k;
          glow(p.x, p.y, (IS_MOBILE ? 28 : 38) * f, a * (0.08 * f));
        }
        glow(head.x, head.y, headR, a * 0.22);
      }
    }

    if (REDUCED) {
      // Reduced motion: keep X subtle but present
      glow(cx, cy, IS_MOBILE ? 56 : 64, 0.02 + 0.06 * xEnergy);
      return;
    }

    if (inA) {
      trail(o => ({ x: lerp(o.x, cx, ease(tin)), y: lerp(o.y, cy, ease(tin)) }), ease(tin), 1);
    } else if (holdA) {
      const c = 0.25 + 0.7 * pulse(th);
      const boost = 1 + 0.85 * xEnergy;
      glow(cx, cy, IS_MOBILE ? 98 : 120, c * 0.35 * boost);
      glow(cx, cy, IS_MOBILE ? 64 : 78,  c * 0.55 * boost);
      glow(cx, cy, IS_MOBILE ? 36 : 44,  c * 0.75 * boost);
    } else if (outA) {
      const a = Math.max(0, 0.9 * (1 - pulse(tout)));
      trail(o => ({ x: lerp(cx, o.x, ease(tout)), y: lerp(cy, o.y, ease(tout)) }), ease(tout), a);
      glow(cx, cy, IS_MOBILE ? 64 : 78, (0.1 + 0.2 * (1 - pulse(tout))) * 0.35 * (1 + 0.7*xEnergy));
    } else {
      glow(cx, cy, IS_MOBILE ? 56 : 64, 0.02 + 0.07 * xEnergy);
    }
  }

  // ==========================================================
  // 2) GAME OF LIFE + "DRIFT TO X" (cells migrate and get absorbed)
  // ==========================================================
  let running = true;
  let stepsPerSecond = REDUCED ? 6 : 12;
  let brush = 1;

  let cellSize = 8;
  let cols = 0, rows = 0;
  let a = null, b = null;

  // Additional buffer for drift (no O(n^2))
  let driftBuf = null;

  function idx(x, y) { return y * cols + x; }

  function initLife() {
    const minDim = Math.min(W, H);
    cellSize = minDim < 520 ? 9 : 8;
    if (minDim < 380) cellSize = 10;

    cols = Math.max(44, Math.floor(W / cellSize));
    rows = Math.max(34, Math.floor(H / cellSize));

    a = new Uint8Array(cols * rows);
    b = new Uint8Array(cols * rows);
    driftBuf = new Uint8Array(cols * rows);

    seedNice();
  }

  function seedNice() {
    a.fill(0);
    // softer noise (prevents full chaos)
    const noise = IS_MOBILE ? 0.075 : 0.085;
    for (let i = 0; i < a.length; i++) a[i] = (Math.random() < noise) ? 1 : 0;

    // a few clusters
    const blobs = IS_MOBILE ? 3 : 4;
    for (let k = 0; k < blobs; k++) {
      const cx = (Math.random() * cols) | 0;
      const cy = (Math.random() * rows) | 0;
      const r = 6 + ((Math.random() * 10) | 0);
      for (let y = -r; y <= r; y++) for (let x = -r; x <= r; x++) {
        const xx = cx + x, yy = cy + y;
        if (xx < 1 || yy < 1 || xx >= cols - 1 || yy >= rows - 1) continue;
        if (x*x + y*y <= r*r && Math.random() < 0.35) a[idx(xx, yy)] = 1;
      }
    }
  }

  function clearLife() { a.fill(0); }
  function randomizeLife() {
    const p = IS_MOBILE ? 0.12 : 0.14;
    for (let i = 0; i < a.length; i++) a[i] = (Math.random() < p) ? 1 : 0;
  }

  // Distance to diagonals in *cell coords* (cheap)
  function distToDiag1Cell(x, y) {
    // y ~= (rows/cols)*x
    const m = rows / cols;
    return Math.abs(y - m * x);
  }
  function distToDiag2Cell(x, y) {
    // y ~= rows - (rows/cols)*x
    const m = rows / cols;
    return Math.abs(y - (rows - m * x));
  }

  // drift pass: gently move living cells towards nearest diagonal (the X)
  function driftToX() {
    driftBuf.fill(0);

    const near = IS_MOBILE ? 1.6 : 2.0;      // distance in cell units to "stick" on X
    const driftProb = IS_MOBILE ? 0.18 : 0.22; // probability to drift per alive cell per tick

    let fed = 0;

    for (let y = 1; y < rows - 1; y++) {
      for (let x = 1; x < cols - 1; x++) {
        if (!a[idx(x, y)]) continue;

        const d1 = distToDiag1Cell(x, y);
        const d2 = distToDiag2Cell(x, y);
        const d = Math.min(d1, d2);

        // If close to X: stick + feed energy (absorption)
        if (d <= near) {
          driftBuf[idx(x, y)] = 1;
          // feed energy proportional to density on the X
          fed++;
          continue;
        }

        // Drift some fraction of cells (keeps Life "alive", not all sucked instantly)
        if (Math.random() > driftProb) {
          driftBuf[idx(x, y)] = 1;
          continue;
        }

        // choose target point on nearest diagonal (approx) in cell coords
        // We push one step towards the diagonal: compute desired y for each diagonal
        const m = rows / cols;
        let tx = x, ty = y;

        if (d1 <= d2) {
          const yOn = m * x;
          // move one step towards yOn
          const dy = yOn - y;
          ty = y + (dy > 0 ? 1 : -1);
          // small x correction to avoid vertical striping
          if (Math.random() < 0.35) tx = x + (Math.random() < 0.5 ? -1 : 1);
        } else {
          const yOn = (rows - m * x);
          const dy = yOn - y;
          ty = y + (dy > 0 ? 1 : -1);
          if (Math.random() < 0.35) tx = x + (Math.random() < 0.5 ? -1 : 1);
        }

        tx = clamp(tx, 1, cols - 2);
        ty = clamp(ty, 1, rows - 2);

        // If occupied, keep original to avoid collisions blowing up
        if (driftBuf[idx(tx, ty)] === 0) driftBuf[idx(tx, ty)] = 1;
        else driftBuf[idx(x, y)] = 1;
      }
    }

    // swap a <- driftBuf
    a.set(driftBuf);

    // Feed X energy in a controlled way
    if (fed > 0) {
      // normalize by grid size so it behaves similarly on all devices
      const norm = fed / (cols * rows);
      feedXEnergy(clamp(norm * 18, 0, 0.12));
    }
  }

  function stepLife() {
    // Conway B3/S23 with wrap (toroidal) keeps it alive
    const w = cols, h = rows;
    let alive = 0;

    for (let y = 0; y < h; y++) {
      const ym1 = (y - 1 + h) % h;
      const yp1 = (y + 1) % h;

      for (let x = 0; x < w; x++) {
        const xm1 = (x - 1 + w) % w;
        const xp1 = (x + 1) % w;

        const n =
          a[idx(xm1, ym1)] + a[idx(x, ym1)] + a[idx(xp1, ym1)] +
          a[idx(xm1, y)]                 +     a[idx(xp1, y)] +
          a[idx(xm1, yp1)] + a[idx(x, yp1)] + a[idx(xp1, yp1)];

        const here = a[idx(x, y)];
        const next = (here === 1)
          ? (n === 2 || n === 3 ? 1 : 0)
          : (n === 3 ? 1 : 0);

        b[idx(x, y)] = next;
        alive += next;
      }
    }

    const tmp = a; a = b; b = tmp;
    return alive;
  }

  function drawLife(aliveCount) {
    // background
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, W, H);

    // draw Life cells with glow (iog-ish but controlled)
    ctx.save();
    ctx.globalCompositeOperation = "lighter";

    const GLOW_A = IS_MOBILE ? 0.22 : 0.28;
    const CELL_A = 0.90;

    for (let y = 0; y < rows; y++) {
      const py = y * cellSize;
      for (let x = 0; x < cols; x++) {
        if (!a[idx(x, y)]) continue;

        const px = x * cellSize;
        const cx = px + cellSize * 0.5;
        const cy = py + cellSize * 0.5;

        // Color field: outside X = subtle color nebula, near X = cyan/white
        const d1 = distToDiag1Cell(x, y);
        const d2 = distToDiag2Cell(x, y);
        const d = Math.min(d1, d2);

        const nearT = clamp(1 - (d / (IS_MOBILE ? 6 : 7)), 0, 1);

        // base nebula color (magenta -> cyan) depending on position
        const t = (x / Math.max(1, cols - 1)) * 0.7 + (y / Math.max(1, rows - 1)) * 0.3;
        const r = Math.floor(lerp(255, 0,  nearT));          // near X -> less red
        const g = Math.floor(lerp(40,  234, nearT));         // near X -> more green (cyan)
        const bcol = Math.floor(lerp(120 + 80*t, 255, nearT));

        // glow
        const rr = cellSize * (IS_MOBILE ? 1.6 : 1.8);
        const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, rr);
        grad.addColorStop(0, `rgba(${r},${g},${bcol},${GLOW_A})`);
        grad.addColorStop(0.35, `rgba(${r},${g},${bcol},${GLOW_A * 0.35})`);
        grad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(cx, cy, rr, 0, Math.PI * 2);
        ctx.fill();

        // core
        ctx.fillStyle = `rgba(255,255,255,${CELL_A * (0.75 + 0.25*nearT)})`;
        ctx.fillRect(px + 1, py + 1, Math.max(1, cellSize - 2), Math.max(1, cellSize - 2));
      }
    }

    ctx.restore();

    if (statusEl) {
      statusEl.textContent =
        `${running ? "RUNNING" : "PAUSED"} · ${stepsPerSecond}/s\ncells: ${aliveCount.toLocaleString()}`;
    }
  }

  // ==========================================================
  // 3) Interaction (paint / keys) like your Life index
  // ==========================================================
  const pointer = { down:false };

  function paintAt(clientX, clientY, val=1) {
    const x = Math.floor(clientX / cellSize);
    const y = Math.floor(clientY / cellSize);
    if (x < 0 || y < 0 || x >= cols || y >= rows) return;

    for (let yy = -brush; yy <= brush; yy++) for (let xx = -brush; xx <= brush; xx++) {
      const nx = x + xx, ny = y + yy;
      if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) continue;
      if (xx*xx + yy*yy <= brush*brush) a[idx(nx, ny)] = val;
    }
  }

  canvas.addEventListener("mousedown", (e) => {
    pointer.down = true;
    paintAt(e.clientX, e.clientY, 1);
  });
  window.addEventListener("mouseup", () => { pointer.down = false; });

  window.addEventListener("mousemove", (e) => {
    if (!pointer.down) return;
    paintAt(e.clientX, e.clientY, 1);
  }, { passive: true });

  canvas.addEventListener("touchstart", (e) => {
    pointer.down = true;
    const t = e.touches && e.touches[0];
    if (!t) return;
    paintAt(t.clientX, t.clientY, 1);
  }, { passive: true });

  window.addEventListener("touchend", () => { pointer.down = false; }, { passive:true });
  window.addEventListener("touchmove", (e) => {
    if (!pointer.down) return;
    const t = e.touches && e.touches[0];
    if (!t) return;
    paintAt(t.clientX, t.clientY, 1);
  }, { passive:true });

  function toggleRun(){ running = !running; }

  window.addEventListener("keydown", (e) => {
    if (e.key === " "){ e.preventDefault(); toggleRun(); }
    if (e.key === "r" || e.key === "R"){ randomizeLife(); }
    if (e.key === "c" || e.key === "C"){ clearLife(); }
    if (e.key === "+" || e.key === "="){ stepsPerSecond = Math.min(60, stepsPerSecond + 2); }
    if (e.key === "-" || e.key === "_"){ stepsPerSecond = Math.max(1, stepsPerSecond - 2); }
    if (e.key === "1") brush = 1;
    if (e.key === "2") brush = 2;
    if (e.key === "3") brush = 3;
  });

  // ==========================================================
  // 4) Main loop (Life -> X overlay)
  // ==========================================================
  let acc = 0;
  let last = performance.now();

  function frame(now){
    // FPS cap for mobile/iOS
    if (TARGET_FPS !== 60){
      const minDt = 1000 / TARGET_FPS;
      if (now - lastFrameMs < minDt){
        requestAnimationFrame(frame);
        return;
      }
      lastFrameMs = now;
    }

    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;

    if (running){
      acc += dt;
      const stepDt = 1 / Math.max(1, stepsPerSecond);

      let steps = 0;
      while (acc >= stepDt && steps < 4){
        // Drift to X first (absorption), then normal Life step
        driftToX();
        var aliveCount = stepLife();
        acc -= stepDt;
        steps++;
      }
      // draw after stepping
      drawLife(aliveCount || 0);
    } else {
      // still draw sometimes so X keeps breathing
      drawLife(countAliveQuick());
    }

    // overlay X pulse on top of Life (original style, boosted by absorption)
    renderXPulse(now);

    requestAnimationFrame(frame);
  }

  function countAliveQuick(){
    let c = 0;
    for (let i=0;i<a.length;i++) c += a[i];
    return c;
  }

  // Init
  resize();
  requestAnimationFrame(frame);

  // Pause when tab hidden (prevents wasting CPU)
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "hidden") running = false;
  });
})();
</script>

</body>
</html>
