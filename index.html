<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>microretailX // Gato Neuronal</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #0d1117; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.157/examples/jsm/controls/OrbitControls.js';

    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 250;

    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    let controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const particleCount = 200;
    let particles = [];
    const nodes = [];

    const particleGeometry = new THREE.SphereGeometry(1.8, 6, 6);
    const particleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });

    for (let i = 0; i < particleCount; i++) {
      let particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
      particle.position.set(
        (Math.random() - 0.5) * 400,
        (Math.random() - 0.5) * 400,
        (Math.random() - 0.5) * 400
      );
      scene.add(particle);
      particles.push({ mesh: particle, target: null, absorbed: false });
    }

    // Gato simplificado con 300 nodos definidos manualmente (random 3D positions)
    for (let i = 0; i < 300; i++) {
      const node = new THREE.Vector3(
        Math.sin(i * 0.3) * 80 + (Math.random() - 0.5) * 10,
        Math.cos(i * 0.5) * 50 + (Math.random() - 0.5) * 10,
        Math.sin(i * 0.7) * 40 + (Math.random() - 0.5) * 10
      );
      nodes.push({ pos: node, occupied: false });
    }

    // Red neuronal visual
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x66ffff, transparent: true, opacity: 0.4 });
    const lineGeometry = new THREE.BufferGeometry();
    const linePositions = new Float32Array(particleCount * 6); // line start and end
    lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
    const lineMesh = new THREE.LineSegments(lineGeometry, lineMaterial);
    scene.add(lineMesh);

    // Absorción lógica
    function absorbParticles() {
      for (let p of particles) {
        if (!p.absorbed) {
          const target = nodes.find(n => !n.occupied);
          if (target) {
            p.target = target;
            target.occupied = true;
            p.absorbed = true;
          }
        }
      }
    }

    absorbParticles();

    function animate() {
      requestAnimationFrame(animate);

      for (let i = 0; i < particles.length; i++) {
        let p = particles[i];
        if (p.absorbed && p.target) {
          let mesh = p.mesh;
          mesh.position.lerp(p.target.pos, 0.07);

          // Optional pulsing color
          const t = Date.now() * 0.002 + i;
          mesh.material.color.setHSL((t % 360) / 360, 1, 0.6);

          // Update line
          linePositions[i * 6 + 0] = mesh.position.x;
          linePositions[i * 6 + 1] = mesh.position.y;
          linePositions[i * 6 + 2] = mesh.position.z;

          linePositions[i * 6 + 3] = p.target.pos.x;
          linePositions[i * 6 + 4] = p.target.pos.y;
          linePositions[i * 6 + 5] = p.target.pos.z;
        }
      }

      lineGeometry.attributes.position.needsUpdate = true;
      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
