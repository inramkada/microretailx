<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>XSHADOWS OPS by microretailX</title>
  <style>
    html, body { margin: 0; padding: 0; background: #000; overflow: hidden; }
    canvas { display: block; }
    .flash {
      position: fixed;
      width: 100%; height: 100%;
      top: 0; left: 0;
      background: rgba(255, 0, 0, 0.1);
      pointer-events: none;
      opacity: 0;
      animation: none;
      z-index: 5;
    }
    @keyframes flashRed {
      0%   { opacity: 0.1; }
      50%  { opacity: 0.35; }
      100% { opacity: 0.1; }
    }
  </style>
</head>
<body>
<div class="flash" id="flash"></div>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';

// Escena, cámara y render
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 50;
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Nodos base (teseracto 16 vértices)
const tesseract4D = [];
for (let i = 0; i < 16; i++) {
  tesseract4D.push([
    (i & 1) ? 1 : -1,
    (i & 2) ? 1 : -1,
    (i & 4) ? 1 : -1,
    (i & 8) ? 1 : -1
  ]);
}
let current4D = tesseract4D.map(v => [...v]);

// Proyección 4D a 3D
function project(v) {
  const w = 2 / (4 - v[3]);
  return new THREE.Vector3(v[0]*w*10, v[1]*w*10, v[2]*w*10);
}

// Material puntos redondos
const pointMat = new THREE.PointsMaterial({
  color: 0x00ffff, size: 0.5, sizeAttenuation: true
});
const geo = new THREE.BufferGeometry();
const positions = new Float32Array(16 * 3);
geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
const points = new THREE.Points(geo, pointMat);
scene.add(points);

// Líneas del teseracto
const lines = new THREE.Group();
scene.add(lines);

// Función para actualizar líneas conectando vértices 1-bit diferente
function updateEdges(proj) {
  lines.clear();
  for (let i = 0; i < 16; i++) {
    for (let j = i + 1; j < 16; j++) {
      const diff = tesseract4D[i].reduce((acc, val, k) => acc + (val !== tesseract4D[j][k] ? 1 : 0), 0);
      if (diff === 1) {
        const lineGeo = new THREE.BufferGeometry().setFromPoints([proj[i], proj[j]]);
        const lineMat = new THREE.LineBasicMaterial({ color: pointMat.color, transparent: true, opacity: 0.15 });
        lines.add(new THREE.Line(lineGeo, lineMat));
      }
    }
  }
}

// Rotación de ejes 4D
function rotate4D(v, i, j, angle) {
  const cos = Math.cos(angle), sin = Math.sin(angle);
  const temp = v[i]*cos - v[j]*sin;
  v[j] = v[i]*sin + v[j]*cos;
  v[i] = temp;
}

// Estados
let lastMove = Date.now();
let inXMode = false;
let dispersed = false;
const flash = document.getElementById("flash");

// Mouse control
const rotation = new THREE.Vector2();
window.addEventListener('mousemove', e => {
  lastMove = Date.now();
  rotation.x = (e.clientY / window.innerHeight - 0.5) * Math.PI;
  rotation.y = (e.clientX / window.innerWidth - 0.5) * Math.PI;
});

// Clic: modo X
window.addEventListener('click', () => {
  inXMode = true;
  dispersed = false;
  flash.style.animation = "flashRed 0.5s infinite";
  pointMat.color.set(0xff0000);
});

// Coordenadas X (solo 20 puntos)
const xCoords = Array.from({length: 20}, (_, i) => {
  const v = (i - 10);
  return new THREE.Vector3(v*1.2, v*1.2, v*0.3);
});

// Dispersión aleatoria
const dispersedCoords = Array.from({length: 16}, () => new THREE.Vector3(
  (Math.random() - 0.5) * 100,
  (Math.random() - 0.5) * 100,
  (Math.random() - 0.5) * 100
));

// Animación
function animate() {
  requestAnimationFrame(animate);

  const now = Date.now();
  const proj = [];

  // Movimiento/rotación 4D
  for (let i = 0; i < current4D.length; i++) {
    if (!inXMode) {
      rotate4D(current4D[i], 0, 3, 0.01);
      rotate4D(current4D[i], 1, 2, 0.012);
    }
    const v3 = project(current4D[i]);
    proj.push(v3);
    positions[i * 3] = v3.x;
    positions[i * 3 + 1] = v3.y;
    positions[i * 3 + 2] = v3.z;
  }

  // Estado: X mode
  if (inXMode) {
    for (let i = 0; i < Math.min(xCoords.length, 16); i++) {
      const p = geo.attributes.position;
      p.setXYZ(i, xCoords[i].x, xCoords[i].y, xCoords[i].z);
    }
    geo.attributes.position.needsUpdate = true;
    updateEdges(xCoords.slice(0, 16));
    return renderer.render(scene, camera);
  }

  // Dispersar si han pasado más de 3s sin mover
  if (!dispersed && now - lastMove > 3000) {
    dispersed = true;
    pointMat.color.set(0x444444);
    flash.style.animation = "none";
  }

  // Reconectar si mueves
  if (now - lastMove < 3000 && dispersed) {
    dispersed = false;
    pointMat.color.set(0x00ffff);
  }

  // Transición hacia disperso
  if (dispersed) {
    for (let i = 0; i < 16; i++) {
      proj[i].lerp(dispersedCoords[i], 0.02);
      positions[i * 3] = proj[i].x;
      positions[i * 3 + 1] = proj[i].y;
      positions[i * 3 + 2] = proj[i].z;
    }
  }

  geo.attributes.position.needsUpdate = true;
  updateEdges(proj);
  points.rotation.x += (rotation.x - points.rotation.x) * 0.05;
  points.rotation.y += (rotation.y - points.rotation.y) * 0.05;
  lines.rotation.copy(points.rotation);
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
