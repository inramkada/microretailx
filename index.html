import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 100;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

const tesseractSize = 4;
const DISPERSION_SCALE = 80;
const MAX_CLICKS = 10;
let clickCount = 0;

const nodes = [];
const velocities = [];
const positions = new Float32Array(10000 * 3); // soporte hasta 10000 nodos

const geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

const material = new THREE.PointsMaterial({ color: 0x00ffff, size: 1.2 });
const points = new THREE.Points(geometry, material);
scene.add(points);

const lineGroup = new THREE.Group();
scene.add(lineGroup);

// Inicializar tesseracto
const offset = tesseractSize / 2 - 0.5;
for (let x = 0; x < tesseractSize; x++) {
  for (let y = 0; y < tesseractSize; y++) {
    for (let z = 0; z < tesseractSize; z++) {
      const pos = new THREE.Vector3(
        (x - offset) * 10,
        (y - offset) * 10,
        (z - offset) * 10
      );
      nodes.push(pos);
      velocities.push(new THREE.Vector3());
    }
  }
}

// Control de ratón
const mouse = new THREE.Vector2();
let repel = false;

window.addEventListener('mousemove', (e) => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
});

window.addEventListener('click', () => {
  if (clickCount < MAX_CLICKS) {
    for (let i = 0; i < 5; i++) {
      const newNode = new THREE.Vector3(
        (Math.random() - 0.5) * DISPERSION_SCALE,
        (Math.random() - 0.5) * DISPERSION_SCALE,
        (Math.random() - 0.5) * DISPERSION_SCALE
      );
      nodes.push(newNode);
      velocities.push(new THREE.Vector3());
    }
    clickCount++;
    if (clickCount >= MAX_CLICKS) repel = true;
  }
});

// Raycaster para repulsión
const raycaster = new THREE.Raycaster();
const cursor = new THREE.Vector2();

function updateLines() {
  lineGroup.clear();
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      const dist = nodes[i].distanceTo(nodes[j]);
      if (dist < 20) {
        const geo = new THREE.BufferGeometry().setFromPoints([nodes[i], nodes[j]]);
        const mat = new THREE.LineBasicMaterial({ color: material.color, transparent: true, opacity: 0.1 });
        lineGroup.add(new THREE.Line(geo, mat));
      }
    }
  }
}

function animate() {
  requestAnimationFrame(animate);

  // Cámara
  raycaster.setFromCamera(mouse, camera);
  const repelPoint = raycaster.ray.origin;

  for (let i = 0; i < nodes.length; i++) {
    let node = nodes[i];
    let vel = velocities[i];

    // Repulsión tras máximo clics
    if (repel) {
      const distance = node.distanceTo(repelPoint);
      if (distance < 20) {
        const dir = node.clone().sub(repelPoint).normalize();
        vel.add(dir.multiplyScalar(0.4));
      }
    }

    // Movimiento suave
    node.add(vel);
    vel.multiplyScalar(clickCount >= MAX_CLICKS ? 0.85 : 0.92);

    // Posiciones al buffer
    positions[i * 3] = node.x;
    positions[i * 3 + 1] = node.y;
    positions[i * 3 + 2] = node.z;
  }

  geometry.setDrawRange(0, nodes.length);
  geometry.attributes.position.needsUpdate = true;

  updateLines();
  renderer.render(scene, camera);
}

animate();
