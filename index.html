
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>XSHADOWS OPS | microretailX</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background-color: #0d1117;
      overflow: hidden;
      font-family: 'Segoe UI', sans-serif;
    }
    .title {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 1.8rem;
      white-space: nowrap;
      z-index: 10;
    }
    .title strong {
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="title">XSHADOWS OPS by <strong>microretailX</strong></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script>
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const mouse = { x: 0.5, y: 0.5 };
    let exploded = false;
    let clickCount = 0;

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.PointLight(0x00ffff, 1, 10);
    directionalLight.position.set(0, 0, 5);
    scene.add(directionalLight);

    const xGeo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-4, -4, 0),
      new THREE.Vector3(4, 4, 0),
      new THREE.Vector3(-4, 4, 0),
      new THREE.Vector3(4, -4, 0)
    ]);
    const xMat = new THREE.LineBasicMaterial({ color: 0x888888, linewidth: 8, transparent: true, opacity: 0.9 });
    const xLine = new THREE.LineSegments(xGeo, xMat);
    scene.add(xLine);

    const baseCoords = [
      [-1, 1, 0], [0, 1.2, 0], [1, 1, 0],
      [-0.8, 0.5, 0], [-0.4, 0.4, 0],
      [0.4, 0.4, 0], [0.8, 0.5, 0],
      [0, 0.3, 0],
      [-0.6, -0.4, 0], [-0.2, -0.6, 0],
      [0.2, -0.6, 0], [0.6, -0.4, 0],
      [-0.5, -1, 0], [0.5, -1, 0], [0, -1.3, 0]
    ];

    const targets = [];
    const geometry = new THREE.BufferGeometry();
    const positions = [];

    for (let i = 0; i < baseCoords.length; i++) {
      positions.push(0, 0, 0);
      targets.push(new THREE.Vector3(...baseCoords[i]));
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    const material = new THREE.PointsMaterial({ size: 0.1, color: 0x00ffff });
    const points = new THREE.Points(geometry, material);
    scene.add(points);

    const lineGeo = new THREE.BufferGeometry();
    const lineMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.2 });
    const lineSegments = new THREE.LineSegments(lineGeo, lineMat);
    scene.add(lineSegments);

    camera.position.z = 6;

    function animate() {
      requestAnimationFrame(animate);
      const pos = geometry.attributes.position;
      const verts = [];

      for (let i = 0; i < targets.length; i++) {
        const idx = i * 3;
        if (exploded) {
          pos.array[idx] = THREE.MathUtils.lerp(pos.array[idx], targets[i].x, 0.1);
          pos.array[idx + 1] = THREE.MathUtils.lerp(pos.array[idx + 1], targets[i].y, 0.1);
          pos.array[idx + 2] = THREE.MathUtils.lerp(pos.array[idx + 2], targets[i].z, 0.1);
        }
        verts.push(new THREE.Vector3(pos.array[idx], pos.array[idx + 1], pos.array[idx + 2]));
      }
      pos.needsUpdate = true;

      const lineVerts = [];
      for (let i = 0; i < verts.length; i++) {
        for (let j = i + 1; j < verts.length; j++) {
          const dist = verts[i].distanceTo(verts[j]);
          if (dist < 1.2) {
            lineVerts.push(verts[i].x, verts[i].y, verts[i].z);
            lineVerts.push(verts[j].x, verts[j].y, verts[j].z);
          }
        }
      }

      lineGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(lineVerts), 3));

      points.rotation.y += (mouse.x - 0.5) * 0.005;
      points.rotation.x += (mouse.y - 0.5) * 0.005;
      lineSegments.rotation.copy(points.rotation);

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('mousemove', e => {
      mouse.x = e.clientX / window.innerWidth;
      mouse.y = e.clientY / window.innerHeight;
    });

    window.addEventListener('click', () => {
      clickCount++;
      if (clickCount === 1) {
        scene.remove(xLine);
        exploded = true;
      }
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
