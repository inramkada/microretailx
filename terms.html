<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SYSTEM CORE | MICRORETAILX</title>
  <style>
    :root { 
      --accent: #00f2ff; 
      --accent-dim: rgba(0, 242, 255, 0.15);
      --bg: #000; 
    }
    
    html, body { 
      margin: 0; padding: 0; height: 100%; 
      background: var(--bg); overflow: hidden; 
      color: #fff; font-family: "JetBrains Mono", "Cascadia Code", monospace; 
    }

    canvas { 
      display: block; width: 100vw; height: 100vh; 
      filter: contrast(1.1) brightness(1.05) saturate(1.2); 
    }

    .ui-layer { position: fixed; inset: 0; pointer-events: none; z-index: 10; }

    .top-bar {
      position: absolute; top: 0; left: 0; right: 0;
      padding: 24px 32px;
      display: flex; justify-content: space-between; align-items: center;
      background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
      border-top: 1px solid var(--accent-dim);
      backdrop-filter: blur(4px);
    }

    .brand {
      font-size: 11px; letter-spacing: 5px; font-weight: 800;
      text-transform: uppercase; color: var(--accent);
      text-shadow: 0 0 15px var(--accent-dim);
    }

    .status {
      font-size: 9px; letter-spacing: 2px; color: rgba(255,255,255,0.4);
      display: flex; align-items: center; gap: 10px;
    }

    .footer-bar {
      position: absolute; bottom: 0; left: 0; right: 0;
      padding: 20px 32px;
      background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
      border-bottom: 1px solid var(--accent-dim);
    }

    .links { display: flex; gap: 24px; margin-bottom: 8px; }
    .links a { 
      font-size: 10px; color: rgba(255,255,255,0.5); 
      text-decoration: none; transition: 0.2s; letter-spacing: 2px;
      pointer-events: auto;
    }
    .links a:hover { color: var(--accent); opacity: 1; }

    .copy { font-size: 8px; opacity: 0.25; letter-spacing: 1px; }

    /* Animación del indicador de vida */
    .dot { width: 5px; height: 5px; background: var(--accent); border-radius: 50%; box-shadow: 0 0 8px var(--accent); animation: pulse 2s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.4; transform: scale(0.8); } }
  </style>
</head>
<body>

  <canvas id="view"></canvas>

  <div class="ui-layer">
    <div class="top-bar">
      <div class="brand">Protocol_X // Maintenance</div>
      <div class="status"><span class="dot"></span> NODE_ACTIVE [0x42F]</div>
    </div>

    <div class="footer-bar">
      <div class="links">
        <a href="#">ACCESS_CORE</a>
        <a href="#">LEGAL_RESOURCES</a>
        <a href="#">ENCRYPT_MODULE</a>
      </div>
      <div class="copy">© 2026 MICRORETAILX LLC // KERNEL_V3.0.1 // UNIFIED_REPLICANT</div>
    </div>
  </div>

  <script>
    (() => {
      "use strict";

      const view = document.getElementById("view");
      const vctx = view.getContext("2d", { alpha: false });
      const simCanvas = document.createElement("canvas");
      const sctx = simCanvas.getContext("2d", { willReadFrequently: true });

      const IS_MOBILE = /Mobi|Android/i.test(navigator.userAgent);
      
      let W, H, simW, simH, dpr;
      let trailA, trailB, xField, imgData, img8;
      let agents = [], foods = [];
      let frame = 0, tPrev = performance.now();

      const CFG = {
        agentCount: IS_MOBILE ? 7500 : 16000,
        step: IS_MOBILE ? 0.9 : 1.15,
        sensorDist: 10.5,
        sensorAngle: 0.56,
        turnSpeed: 0.36,
        deposit: 0.75,
        decay: IS_MOBILE ? 0.968 : 0.974,
        diffuseMix: 0.45,
        xBias: 0.88,           // Intensidad de la guía diagonal (X)
        foodLifeMs: 1400,      // Cuánto dura el rastro al hacer clic
        foodStrength: 1.8      // Atracción al rastro del usuario
      };

      function resize() {
        dpr = Math.min(2, window.devicePixelRatio || 1);
        W = window.innerWidth; H = window.innerHeight;
        view.width = W * dpr; view.height = H * dpr;
        vctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        // Escalado inteligente para rendimiento
        const maxSide = IS_MOBILE ? 480 : 720;
        const aspect = W / H;
        simW = aspect >= 1 ? maxSide : (maxSide * aspect) | 0;
        simH = aspect >= 1 ? (maxSide / aspect) | 0 : maxSide;

        simCanvas.width = simW;
        simCanvas.height = simH;

        const n = simW * simH;
        trailA = new Float32Array(n).fill(0);
        trailB = new Float32Array(n).fill(0);
        xField = new Float32Array(n);
        
        imgData = sctx.createImageData(simW, simH);
        img8 = imgData.data;

        buildXField();
        seed();
      }

      function buildXField() {
        const a = (simH - 1) / (simW - 1);
        const inv = 1 / Math.sqrt(1 + a*a);
        const thickness = 18; // Definición de la X
        for (let y = 0; y < simH; y++) {
          for (let x = 0; x < simW; x++) {
            const d1 = Math.abs(a * x - y) * inv;
            const d2 = Math.abs(a * x + y - (simH - 1)) * inv;
            const d = Math.min(d1, d2);
            xField[x + y * simW] = Math.exp(-(d * d) / thickness);
          }
        }
      }

      function seed() {
        agents = Array.from({ length: CFG.agentCount }, () => ({
          x: Math.random() * simW,
          y: Math.random() * simH,
          a: Math.random() * Math.PI * 2
        }));
      }

      function addFood(x, y) {
        const fx = (x / W) * simW;
        const fy = (y / H) * simH;
        foods.push({ x: fx, y: fy, life: CFG.foodLifeMs });
      }

      const getVal = (f, x, y) => {
        if (x < 0 || x >= simW || y < 0 || y >= simH) return 0;
        return f[(x | 0) + (y | 0) * simW];
      };

      function update(dt) {
        // Actualizar comida activa
        for (let i = foods.length - 1; i >= 0; i--) {
          foods[i].life -= dt;
          if (foods[i].life <= 0) foods.splice(i, 1);
        }

        for (let p of agents) {
          const sense = (angle) => {
            const sx = p.x + Math.cos(p.a + angle) * CFG.sensorDist;
            const sy = p.y + Math.sin(p.a + angle) * CFG.sensorDist;
            let val = getVal(trailA, sx, sy) + getVal(xField, sx, sy) * CFG.xBias;
            
            for (let f of foods) {
              const dx = sx - f.x, dy = sy - f.y;
              const d2 = dx*dx + dy*dy;
              if (d2 < 800) val += (CFG.foodStrength * (f.life / CFG.foodLifeMs)) / (1 + d2 * 0.1);
            }
            return val;
          };

          const f = sense(0), l = sense(-CFG.sensorAngle), r = sense(CFG.sensorAngle);

          if (f > l && f > r) {} 
          else if (l > r) p.a -= CFG.turnSpeed;
          else if (r > l) p.a += CFG.turnSpeed;
          else p.a += (Math.random() - 0.5) * 0.15;

          p.x += Math.cos(p.a) * CFG.step;
          p.y += Math.sin(p.a) * CFG.step;

          if (p.x < 0) p.x += simW; else if (p.x >= simW) p.x -= simW;
          if (p.y < 0) p.y += simH; else if (p.y >= simH) p.y -= simH;

          const idx = (p.x | 0) + (p.y | 0) * simW;
          trailA[idx] = Math.min(1.0, trailA[idx] + CFG.deposit);
        }

        for (let i = 0; i < trailA.length; i++) trailA[i] *= CFG.decay;

        if (frame % 2 === 0) {
          // Difusión simple pero rápida
          for (let i = simW; i < trailA.length - simW; i++) {
            trailB[i] = (trailA[i] + trailA[i-1] + trailA[i+1] + trailA[i-simW] + trailA[i+simW]) / 5;
          }
          [trailA, trailB] = [trailB, trailA];
        }
        frame++;
      }

      function render() {
        for (let i = 0; i < trailA.length; i++) {
          const v = Math.pow(Math.min(trailA[i], 1), 0.72);
          const p = i * 4;
          img8[p] = v * 15;        // R
          img8[p + 1] = v * 225;   // G
          img8[p + 2] = v * 255;   // B
          img8[p + 3] = 255;
        }
        sctx.putImageData(imgData, 0, 0);
        vctx.fillStyle = "#000";
        vctx.fillRect(0, 0, W, H);
        vctx.imageSmoothingEnabled = true;
        vctx.drawImage(simCanvas, 0, 0, simW, simH, 0, 0, W, H);
      }

      function loop(now) {
        const dt = now - tPrev;
        tPrev = now;
        update(dt);
        render();
        requestAnimationFrame(loop);
      }

      window.addEventListener("pointermove", e => addFood(e.clientX, e.clientY));
      window.addEventListener("pointerdown", e => addFood(e.clientX, e.clientY));
      window.addEventListener("resize", resize);
      window.addEventListener("keydown", e => { if(e.key.toLowerCase() === 'r') seed(); });

      resize();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
